name,desp,example,synx,parameter,output,module
pow(),The pow() function computes a base number raised to the power of exponent number.,"#include <iostream>
#include <cmath>
using namespace std;

int main ()
{
	double base, exponent, result;
	
	base = 3.4;
	exponent = 4.4;
	result = pow(base, exponent);
	
	cout << base << ""^"" << exponent << "" = "" << result;
	
	return 0;
}","double pow(double base, double exponent);
float pow(float base, float exponent);
long double pow(long double base, long double exponent);
Promoted pow(Type1 base, Type2 exponent); // For other argument types","The pow() function takes two arguments :
base - the base value
exponent - exponent of the base",3.4^4.4 = 218.025,Cmath
llrint(),The llrint() function in C++ rounds the argument to an integral value using the current rounding mode.,"#include <iostream>
#include <cmath>
#include <cfenv>
using namespace std;

int main()
{
    // by default, rounding direction is to-nearest i.e. fesetround(FE_TONEAREST)
    double x = 11.87;
    long long int result;
    result = llrint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;
    
    // mid-way values are rounded off to higher integer
    x = 11.5;
    result = llrint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;

    // setting rounding direction to DOWNWARD
    fesetround(FE_DOWNWARD);
    x = 11.87;
    result = llrint(x);
    cout << ""Rounding downward ("" << x << "") = "" << result << endl;
    
    // setting rounding direction to UPWARD
    fesetround(FE_UPWARD);
    x = 33.32;
    result = llrint(x);
    cout << ""Rounding upward ("" << x << "") = "" << result << endl;
    
    return 0;
}","long long int llrint(double x);
long long int llrint(float x);
long long int llrint(long double x);
long long int llrint(T x); // For integral type",The llrint() function takes a single argument value to round.,"Rounding to-nearest (11.87) = 12
Rounding to-nearest (11.5) = 12
Rounding downward (11.8699) = 11
Rounding upward (33.3201) = 34",Cmath
remainder(),The remainder() function in C++ computes the floating point remainder of numerator/denominator (rounded to nearest).,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = 7.5, y = 2.1;
    double result = remainder(x, y);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;

    x = -17.50, y=2.0;
    result = remainder(x, y);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;
    
    y=0;
    result = remainder(x, y);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;
    
    return 0;
}","double remainder(double x, double y);
float remainder(float x, float y);
long double remainder(long double x, long double y);
double remainder(Type1 x, Type2 y); // Additional overloads for other combinations of arithmetic types","x - The value of numerator.
y - The value of denominator.","Remainder of 7.5/2.1 = -0.9
Remainder of -17.5/2 = 0.5
Remainder of -17.5/0 = -nan",Cmath
cosh(),The cosh() function in C++ returns the hyperbolic cosine of an angle given in radians.,"#include <iostream>
#include <cmath>
using namespace std;
int main()
{
    double x = 4.55, result;

    result = cosh(x);
    cout << ""cosh(x) = "" << result << endl;

    // x in Degrees
    double xDegrees = 90;
    x = xDegrees * 3.14159/180;

    result = cosh(x);
    cout << ""cosh(x) = "" << result << endl;

    return 0;
}","double cosh(double x);
float cosh(float x);
long double cosh(long double x);
double cosh(T x); // For integral type.",The cosh() function takes a single mandatory argument representing a hyperbolic angle in radians.,"cosh(x) = 47.3215
cosh(x) = 2.50918",Cmath
copysign(),The copysign() function in C++ takes two arguments and returns a value with the magnitude of first argument and sign of second argument.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = 34.15, y = -13.0, result;
    
    result = copysign(x, y);
    cout << ""copysign("" << x << "","" << y << "") = "" << result << endl;
    
    return 0;
}","double copysign(double x, double y);
float copysign(float x, float y);
long double copysign(long double x, long double y);
Promoted copysign(Type1 x, Type2 y); // Additional overloads for arithmetic types","x: Value with the magnitude of the resulting value.


y: Value with the sign of the resulting value.","copysign(34.15,-13) = -34.15",Cmath
abs(),The abs() function in C++ returns the absolute value of the argument.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = -87.91, result;
    
    result = abs(x);
    cout << ""abs("" << x << "") = |"" << x << ""| = "" << result << endl;

    return 0;
}","double abs(double x);
float abs(float x);
long double abs(long double x);
double abs(T x); // For integral type","The abs() function takes a single argument, x whose absolute value is returned.",abs(-87.91) = |-87.91| = 87.91,Cmath
fabs(),The fabs() function in C++ returns the absolute value of the argument.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = -10.25, result;
    
    result = fabs(x);
    cout << ""fabs("" << x << "") = |"" << x << ""| = "" << result << endl;

    return 0;
}","double fabs(double x);
float fabs(float x);
long double fabs(long double x);
double fabs(T x); // For integral type","The fabs() function takes a single argument, x whose absolute value is returned.",fabs(-10.25) = |-10.25| = 10.25,Cmath
fdim(),The fdim() function in C++ takes two arguments and returns the positive difference between first and second argument.,"#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    double x = 22.31, y = 13.17, result;
    result = fdim(x, y);
    cout << ""fdim(x, y) = "" << result << endl;

    long double xLD = -22.31, resultLD;
    y = 13.14;
    resultLD = fdim(xLD, y);
    cout << ""fdim(xLD, y) = "" << resultLD << endl;
		
    return 0;
}","double fdim(double x, double y);
float fdim(float x, float y);
long double fdim(long double x, long double y);
Promoted fdim(Type1 x, Type2 y); // For other combinations of arithmetic types.","The fdim() function take two parameters of either floating-point or integral type:x - first argument to fdim()
y - second argument to fdim()","fdim(x, y) = 9.14
fdim(xLD, yLD) = 0",Cmath
fmin(),"The fmin() function in C++ takes two arguments and returns the smallest among them. If one of the argument is NaN, the other argument is returned.","#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = -2.05, y = NAN, result;
    
    result = fmin(x, y);
    cout << ""fmin(x, y) = "" << result << endl;

    return 0;
}","double fmin(double x, double y);
float fmin(float x, float y);
long double fmin(long double x, long double y);
Promoted fmin(Type1 x, Type2 y); // Additional overloads for arithmetic types","x: The first argument of fmin().
y: The second argument of fmin().","fmin(x, y) = -2.05",Cmath
fmax(),"The fmax() function in C++ takes two arguments and returns the largest among them. If one of the argument is NaN, the other argument is returned.","#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = -2.05, y = NAN, result;

    result = fmax(x, y);
    cout << ""fmax(x, y) = "" << result << endl;

    return 0;
}","double fmax(double x, double y);
float fmax(float x, float y);
long double fmax(long double x, long double y);
Promoted fmax(Type1 x, Type2 y); // Additional overloads for arithmetic types","x: The first argument of fmax().
y: The second argument of fmax().","fmax(x, y) = -2.05",Cmath
hypot(),The hypot() function in C++ returns the square root of sum of square of arguments passed.,"#include <iostream>
#include <cmath>
using namespace std;

int main()
{
	double x = 2.1, y = 3.1, result;
	result = hypot(x, y);
	cout << ""hypot(x, y) = "" << result << endl;
	
	long double yLD, resultLD;
	x = 3.52;
	yLD = 5.232342323;
	
	// hypot() returns long double in this case
	resultLD = hypot(x, yLD);
	cout << ""hypot(x, yLD) = "" << resultLD;
	
	return 0;
}","double hypot(double x, double y);
float hypot(float x, float y);
long double hypot(long double x, long double y);
Promoted pow(Type1 x, Type2 y);

double hypot(double x, double y, double x); // (since C++17)
float hypot(float x, float y, float z); // (since C++17)
long double hypot(long double x, long double y, long double z); // (since C++17)
Promoted pow(Type1 x, Type2 y, Type2 y); // (since C++17)",The hytpot() takes either 2 or 3 parameters of integral or floating-point type.,"hypot(x, y) = 3.74433
hypot(x, yLD) = 6.30617",Cmath
nexttoward(),The nexttoward() function in C++ takes two arguments and returns the next representable value after x in the direction of y.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    long double y = -1.0;
    double x = 0.0;
    
    double result = nexttoward(x, y);
    cout << ""nexttoward(x, y) = "" << result << endl;

    return 0;
}","double nexttoward(double x, long double y);
float nexttoward(float x, long float y);
long double nexttoward(long double x, long double y);
double nexttoward(T x, long double y); // For integral type","x: The base value.
y: The value towards which the return value is approximated.","nexttoward(x, y) = -4.94066e-324",Cmath
nextafter(),The nextafter() function in C++ takes two arguments and returns the next representable value after x in the direction of y.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = 0.0, y = 1.0;

    double resultInDouble = nextafter(x,y);
    cout << ""nextafter(x, y) = "" << resultInDouble << endl;

    return 0;
}","double nextafter(double x, double y);
float nextafter(float x, float y);
long double nextafter(long double x, long double y);
Promoted nextafter(Type1 x, Type2 y); // Additional overloads","x: The base value.
y: The value towards which the return value is approximated.","nextafter(x, y) = 4.94066e-324",Cmath
cbrt(),The cbrt() function in C++ returns the cube root of a number.,"#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    double x = -1000.0, result;
    result = cbrt(x);
    cout << ""Cube root of "" << x << "" is "" << result << endl;

    return 0;
}","double cbrt(double x);
float cbrt(float x);
long double cbrt(long double x);
double cbrt(T x); // For integral type",The cbrt() function takes a single argument whose cube root is to be calculated.,Cube root of -1000 is -10,Cmath
sqrt(),The sqrt() function in C++ returns the square root of a number.,"#include <iostream>
#include <cmath>
using namespace std;

int main()
{
	double x = 10.25, result;
	result = sqrt(x);
	cout << ""Square root of "" << x << "" is "" << result << endl;

	return 0;
}","double sqrt(double x);
float sqrt(float x);
long double sqrt(long double x);
double sqrt(T x); // For integral type","The sqrt() function takes a single non-negative argument.If negative argument is passed to sqrt() function, domain error occurs.",Square root of 10.25 is 3.20156,Cmath
remquo(),The remquo() function in C++ computes the floating point remainder of numerator/denominator and also stores the quotient to the pointer passed to it.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    int q;
    double x = 12.5, y = 2.2;

    double result = remquo(x, y, &q);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;
    cout << ""Quotient of "" << x << ""/"" << y << "" = "" << q << endl << endl;

    x = -12.5;
    result = remquo(x, y, &q);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;
    cout << ""Quotient of "" << x << ""/"" << y << "" = "" << q << endl << endl;

    y = 0;
    result = remquo(x, y, &q);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;
    cout << ""Quotient of "" << x << ""/"" << y << "" = "" << q << endl << endl;
    
    return 0;
}","double remquo(double x, double y, int* q); 
float remquo(float x, float y, int* q);
long double remquo(long double x, long double y, int* q);
double remquo(Type1 x, Type2 y, int* q); // Additional overloads for other combinations of arithmetic types.","x: The value of numerator.
y: The value of denominator.
q: Pointer to an object where the quotient internally used to determine the remainder is stored as a value of type int.","Remainder of 12.5/2.2 = -0.7
Quotient of 12.5/2.2 = 6

Remainder of -12.5/2.2 = 0.7
Quotient of -12.5/2.2 = -6

Remainder of -12.5/0 = -nan
Quotient of -12.5/0 = 0",Cmath
logb(),"The logb() function in C++ returns the logarithm of |x|, using FLT_RADIX as base for the logarithm.","#include <iostream>
#include <cmath>

using namespace std;

int main ()
{
	double x = 121.056, result;

	result = logb(x);
	cout << ""logb("" << x << "") = "" << ""log(|"" << x << ""|) = ""<< result << endl;

	return 0;
}","double logb (double x);
float logb (float x);
long double logb (long double x);
double logb (T x); // For integral type",The ilogb() function takes a single argument whose logb is computed.,logb(121.056) = log(|121.056|) = 6,Cmath
log1p(),The log1p() function in C++ takes an argument x and returns the natural logarithm (base-e logarithm) of x+1.,"#include <iostream>
#include <cmath>

using namespace std;

int main ()
{
	double x = 21.371, result;

	result = log1p(x);
	cout << ""log1p(x) = "" << result << endl;

	return 0;
}","double log1p (double x);
float log1p (float x);
long double log1p (long double x);
double log1p (T x); // For integral type","The log1p() function takes a single mandatory argument in the range [-1, ∞].If the value is less than -1, log1p() returns Nan (Not a Number).",log1p(x) = 3.10777,Cmath
scalbln(),"The scalbln() function in C++ takes two arguments: x and n, and scales x by FLT_RADIX raised to the power n.","#include <iostream>
#include <cmath>
#include <cfloat>
using namespace std;

int main ()
{
	long int n = 133;
	double x = 3.056, result;
	result = scalbln (x, n);
	cout << x << "" * "" << FLT_RADIX << ""^"" << n << "" = "" << result << endl;
	
	return 0;
}","double scalbln (double x, long int n);
float scalbln (float x, long int n);
long double scalbln (long double x, long int n);
double scalbln (T x, long int n); // Here, T is an integral type","The scalbln() takes two arguments:x - The value representing the significand.
n - The value of exponent of FLT_RADIX.",3.056 * 2^133 = 3.32769e+40,Cmath
log2(),The log2() function in C++ returns the base-2 logarithm of the argument.,"#include <iostream>
#include <cmath>

using namespace std;

int main ()
{
	double x = 13.056, result;

	result = log2(x);
	cout << ""log2(x) = "" << result << endl;

	x = -3.591;
	result = log2(x);
	cout << ""log2(x) = "" << result << endl;
	
	return 0;
}","double log2(double x);
float log2(float x);
long double log2(long double x);
double log2(T x); // For integral type","The log2() function takes a single mandatory argument in the range [0, ∞].
	If the value is less than zero, log2() returns NaN (Not a Number).","log2(x) = 3.70664
log2(x) = nan",Cmath
scalbn(),"The scalbn() function in C++ takes two arguments: x and n, and scales x by FLT_RADIX raised to the power n.","#include <iostream>
#include <cmath>
#include <cfloat>
using namespace std;

int main ()
{
	int n = 13;
	double x = 3.056, result;
	
	result = scalbn (x, n);
	cout << x << "" * "" << FLT_RADIX << ""^"" << n << "" = "" << result << endl;
	
	return 0;
}","double scalbn (double x, int n);
float scalbn (float x, int n);
long double scalbn (long double x, int n);
double scalbn (T x, int n); // Here, T is an integral type","The scalbn() takes two arguments:x - The value representing the significand.
n - The value of exponent of FLT_RADIX.",3.056 * 2^13 = 25034.8,Cmath
ilogb(),"The ilogb() function in C++ returns the integral part of the logarithm of |x|, using FLT_RADIX as base for the logarithm.","#include <iostream>
#include <cmath>
#include <cfloat>

using namespace std;

int main()
{
	int result;
	double significand;
	double x = 16.81;

	result = ilogb(x);
	significand = x / pow(FLT_RADIX, result);

	cout << ""ilogb ("" << x << "") = "" << result << endl;
	cout << x << "" = "" << significand << "" * "" << FLT_RADIX << ""^"" << result << endl << endl;

	return 0;
}","int ilogb (double x);
int ilogb (float x);
int ilogb (long double x);
int ilogb (T x); // For integral type",The ilogb() function takes a single argument whose ilogb is computed.,"ilogb (16.81) = 4
16.81 = 1.05062 * 2^4",Cmath
nearbyint(),The nearbyint() function in C++ rounds the argument to an integral value using the current rounding mode.,"#include <iostream>
#include <cmath>
#include <cfenv>
using namespace std;

int main()
{
    // by default, rounding direction is to-nearest i.e. fesetround(FE_TONEAREST)
    double x = 11.87, result;
    result = nearbyint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;
    
    // upper value is taken for mid-way values
    x = 11.5;
    result = nearbyint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;

    // setting rounding direction to DOWNWARD
    fesetround(FE_DOWNWARD);
    x = 17.87;
    result = nearbyint(x);
    cout << ""Rounding downward ("" << x << "") = "" << nearbyint(x) << endl;
    
    // setting rounding direction to UPWARD
    x = 33.34;
    fesetround(FE_UPWARD);
    result = nearbyint(x);
    cout << ""Rounding upward ("" << x << "") = "" << result << endl;
    
    return 0;
}","double nearbyint(double x);
float nearbyint(float x);
long double nearbyint(long double x);
double nearbyint(T x); // For integral type",The nearbyint() function takes a single argument value to round.,Rounding to-nearest (11.87) = 12 Rounding to-nearest (11.5) = 12 Rounding downward (17.87) = 17 Rounding upward (33.3401) = 34,Cmath
expm1(),The expm1() function in C++ returns the exponential (Euler's number) e raised to the given argument minus 1.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
	double x = 2.19, result;
	result = expm1(x);
	
	cout << ""e^"" << x << "" - 1 = "" << result << endl;
	
	return 0;
}","double expm1(double x);
float expm1(float x);
long double expm1(long double x); 
double expm1(T x); // Here T is an integral type.","The expm1() function takes a single mandatory argument (can be positive, negative or 0).",e^2.19 - 1 = 7.93521,Cmath
ldexp(),The ldexp() function in C++ takes two arguments: x and exp and returns the product of x and 2 raised to the power of exp i.e. x * 2exp.,"#include <iostream>
#include <cmath>

using namespace std;

int main ()
{
	double x = 13.056, result;
	int exp = 2;
	result = ldexp(x , exp);
	cout << ""ldexp(x, exp) = "" << result << endl;

	return 0;
}","double ldexp (double x, int exp);
float ldexp (float x, int exp);
long double ldexp (long double x, int exp);
double ldexp (T x, int exp); // For integral type","x - The floating point value representing the significand.
exp - The value of exponent.","ldexp(x, exp) = 52.224",Cmath
frexp(),The frexp() function in C++ breaks a floating point number into its binary significand.,"#include <iostream>
#include <cmath>

using namespace std;

int main ()
{
	double x = 6.81, significand;
	int *exp;
	significand = frexp(x , exp);
	cout << x << "" = "" << significand << "" * 2^"" << *exp << endl;

	return 0;
}","double frexp (double x, int* exp);
float frexp (float x, int* exp);
long double frexp (long double x, int* exp);
double frexp (T x, int* exp); // For integral type","x - The value to be decomposed.
exp - The pointer to an integer where the value of exponent is to be stored.",6.81 = 0.85125 * 2^3,Cmath
exp2(),"The exp2() function in C++ returns the base-2 exponential function, i.e. 2 raised to the given argument.","#include <iostream>
#include <cmath>

using namespace std;

int main()
{
	double x = -6.19, result;
	
	result = exp2(x);
	cout << ""exp2(x) = "" << result << endl;

	return 0;
}","double exp2(double x);
float exp2(float x);
long double exp2(long double x);
double exp2(T x); // For integral type","The exp2() function takes a single mandatory argument (can be positive, negative or 0).",exp2(x) = 0.013697,Cmath
exp(),The exp() function in C++ returns the exponential (Euler's number) e raised to the given argument.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
	double x = 2.19, result;
	
	result = exp(x);
	cout << ""exp(x) = "" << result << endl;

	return 0;
}","double exp(double x);
float exp(float x);
long double exp(long double x);
double exp(T x); // For integral type","The exp() function takes a single mandatory argument and can be any value i.e. negative, positive or zero.",exp(x) = 8.93521,Cmath
modf(),The modf() function in C++ breaks a number into integral and fractional part.,"#include <iostream>
#include <cmath>
using namespace std;

int main ()
{
	double x = 14.86, intPart, fractPart;
	
	fractPart = modf(x, &intPart);
	cout << x << "" = "" << intPart << "" + "" << fractPart << endl;
	
	x = -31.201;
	fractPart = modf(x, &intPart);
	cout << x << "" = "" << intPart << "" + "" << fractPart << endl;

	return 0;
}","double modf (double x, double* intpart);
float modf (float x, float* intpart);
long double modf (long double x, long double* intpart);
double modf (T x, double* intpart);  // T is an integral type","The modf() takes two parameters:x - Value to be broken into two parts.
intpart - Pointer to an object (of the same type as x) where the integral part is stored with the same sign as x.","14.86 = 14 + 0.86
-31.201 = -31 + -0.201",Cmath
log10(),The log10() function in C++ returns the common logarithm (base 10 logarithm) of the argument.,"#include <iostream>
#include <cmath>
using namespace std;

int main ()
{
	double x = 13.056, result;
	result = log10(x);
	cout << ""log10(x) = "" << result << endl;
	
	x = -3.591;
	result = log10(x);
	cout << ""log10(x) = "" << result << endl;
	
	return 0;
}","double log10 (double x);
float log10 (float x);
long double log10 (long double x);
double log10 (T x);  // For integral type","The log10() function takes a single mandatory argument in the range [0, ∞].If the value is less than 0, log10() returns NaN (Not a Number).","log10(x) = 1.11581
log10(x) = nan",Cmath
lrint(),The lrint() function in C++ rounds the argument to an integral value using the current rounding mode.,"#include <iostream>
#include <cmath>
#include <cfenv>
using namespace std;

int main()
{
    // by default, rounding direction is to-nearest i.e. fesetround(FE_TONEAREST)
    double x = 11.87;
    long int result;
    result = lrint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;
    
    // mid-way values are rounded off to higher integer
    x = 11.5;
    result = lrint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;

    // setting rounding direction to DOWNWARD
    fesetround(FE_DOWNWARD);
    x = 11.87;
    result = lrint(x);
    cout << ""Rounding downward ("" << x << "") = "" << result << endl;
    
    // setting rounding direction to UPWARD
    fesetround(FE_UPWARD);
    x = 33.32;
    result = lrint(x);
    cout << ""Rounding upward ("" << x << "") = "" << result << endl;
    
    return 0;
}","long int lrint(double x);
long int lrint(float x);
long int lrint(long double x);
long int lrint(T x); // For integral type",The lrint() function takes a single argument value to round.,"Rounding to-nearest (11.87) = 12
Rounding to-nearest (11.5) = 12
Rounding downward (11.8699) = 11
Rounding upward (33.3201) = 34",Cmath
rint(),The rint() function in C++ rounds the argument to an integral value using the current rounding mode.,"#include <iostream>
#include <cmath>
#include <cfenv>
using namespace std;

int main()
{
    // by default, rounding direction is to-nearest i.e. fesetround(FE_TONEAREST)
    double x = 11.87, result;
    result = rint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;
    
    // upper value is taken for mid-way values
    x = 11.5;
    result = rint(x);
    cout << ""Rounding to-nearest ("" << x << "") = "" << result << endl;

    // setting rounding direction to DOWNWARD
    fesetround(FE_DOWNWARD);
    x = 11.87;
    result = rint(x);
    cout << ""Rounding downward ("" << x << "") = "" << result << endl;
    
    // setting rounding direction to UPWARD
    fesetround(FE_UPWARD);
    x = 33.32;
    result = rint(x);
    cout << ""Rounding upward ("" << x << "") = "" << result << endl;
    
    return 0;
}","double rint(double x);
float rint(float x);
long double rint(long double x);
double rint(T x); // For integral type",The rint() function takes a single argument value to round.,"Rounding to-nearest (11.87) = 12
Rounding to-nearest (11.5) = 12
Rounding downward (11.8699) = 11
Rounding upward (33.3201) = 34",Cmath
llround(),"The llround() function in C++ rounds the integer value that is nearest to the argument, with halfway cases rounded away from zero.","#include <iostream>
#include <cmath>

using namespace std;

int main()
{   
    long long int result;
    double x = 11.16;
    result = llround(x);
    cout << ""llround("" << x << "") = "" << result << endl;

    x = 13.87;
    result = llround(x);
    cout << ""llround("" << x << "") = "" << result << endl;
    
    x = 50.5;
    result = llround(x);
    cout << ""llround("" << x << "") = "" << result << endl;
    
    x = -11.16;
    result = llround(x);
    cout << ""llround("" << x << "") = "" << result << endl;

    x = -13.87;
    result = llround(x);
    cout << ""llround("" << x << "") = "" << result << endl;
    
    x = -50.5;
    result = llround(x);
    cout << ""llround("" << x << "") = "" << result << endl;
    
    return 0;
}","long long int llround(double x);
long long int llround(float x);
long long int llround(long double x);
long long int llround(T x); // For integral type",The llround() function takes a single argument value to round.,"llround(11.16) = 11
llround(13.87) = 14
llround(50.5) = 51
llround(-11.16) = -11
llround(-13.87) = -14
llround(-50.5) = -51",Cmath
lround(),"The lround() function in C++ rounds the integer value that is nearest to the argument, with halfway cases rounded away from zero. The value returned is of type long int.","#include <iostream>
#include <cmath>

using namespace std;

int main()
{   
    long int result;
    double x = 11.16;
    result = lround(x);
    cout << ""lround("" << x << "") = "" << result << endl;

    x = 13.87;
    result = lround(x);
    cout << ""lround("" << x << "") = "" << result << endl;
    
    x = 50.5;
    result = lround(x);
    cout << ""lround("" << x << "") = "" << result << endl;
    
    x = -11.16;
    result = lround(x);
    cout << ""lround("" << x << "") = "" << result << endl;

    x = -13.87;
    result = lround(x);
    cout << ""lround("" << x << "") = "" << result << endl;
    
    x = -50.5;
    result = lround(x);
    cout << ""lround("" << x << "") = "" << result << endl;
    
    return 0;
}","long int lround(double x);
long int lround(float x);
long int lround(long double x);
long int lround(T x); // For integral type",The lround() function takes a single argument value to round.,"lround(11.16) = 11
lround(13.87) = 14
lround(50.5) = 51
lround(-11.16) = -11
lround(-13.87) = -14
lround(-50.5) = -51",Cmath
round(),"The round() function in C++ returns the integral value that is nearest to the argument, with halfway cases rounded away from zero.","#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = 11.16, result;
    result = round(x);
    cout << ""round("" << x << "") = "" << result << endl;

    x = 13.87;
    result = round(x);
    cout << ""round("" << x << "") = "" << result << endl;
    
    x = 50.5;
    result = round(x);
    cout << ""round("" << x << "") = "" << result << endl;
    
    x = -11.16;
    result = round(x);
    cout << ""round("" << x << "") = "" << result << endl;

    x = -13.87;
    result = round(x);
    cout << ""round("" << x << "") = "" << result << endl;
    
    x = -50.5;
    result = round(x);
    cout << ""round("" << x << "") = "" << result << endl;
    
    return 0;
}","double round(double x);
float round(float x);
long double round(long double x);
double round(T x); // For integral type",The round() function takes a single argument value to round.,"round(11.16) = 11
round(13.87) = 14
round(50.5) = 51
round(-11.16) = -11
round(-13.87) = -14
round(-50.5) = -51",Cmath
trunc(),The trunc() function in C++ rounds the argument towards zero and returns the nearest integral value that is not larger in magnitude than the argument.,"#include <iostream>
#include <cmath>
 
using namespace std;
 
int main()
{
    double x = 10.25, result;
    result = trunc(x);
    cout << ""trunc("" << x << "") = "" << result << endl;
 
    x = -34.251;
    result = trunc(x);
    cout << ""trunc("" << x << "") = "" << result << endl;
 
    return 0;
}","double trunc(double x);
float trunc(float x);
long double trunc(long double x);
double trunc(T x); // For integral types",The trunc() function takes a single argument whose trunc value is to be computed.,"trunc(10.25) = 10
trunc(-34.251) = -34",Cmath
log(),The log() function in C++ returns the natural logarithm (base-e logarithm) of the argument.,"#include <iostream>
#include <cmath>
using namespace std;

int main ()
{
	double x = 13.056, result;
	result = log (x);
	cout << ""log(x) = "" << result << endl;
	
	x = -3.591;
	result = log (x);
	cout << ""log(x) = "" << result << endl;
	
	return 0;
}","double log (double x);
float log (float x);
long double log (long double x);
double log (T x);  // For integral type","The log() function takes a single mandatory argument in the range [0, ∞].If the value is less than zero, log() returns NaN (Not a Number).","log(x) = 2.56925
log(x) = nan",Cmath
atanh(),The atanh() function in C++ returns the arc hyperbolic tangent (inverse hyperbolic tangent) of a number in radians.,"#include <iostream>
#include <cmath>

#define PI 3.141592654
using namespace std;

int main()
{
	double x = 0.32, result;

	result = atanh(x);
	cout << ""atanh(x) = "" << result << "" radian"" << endl;

	// result in degrees
	cout << ""atanh(x) = "" << result*180/PI << "" degree"" << endl;
	
	return 0;
}","double atanh(double x);
float atanh(float x);
long double atanh(long double x);
double atanh(T x); // For integral type","The atanh() function takes a single mandatory argument in the range [-1, 1].If the value is greater than 1 or less than -1, a domain error occurs.","atanh(x) = 0.331647 radian
atanh(x) = 19.002 degree",Cmath
asinh(),The asinh() function in C++ returns the arc hyperbolic sine (inverse hyperbolic sine) of a number in radians.,"#include <iostream>
#include <cmath>

#define PI 3.141592654
using namespace std;

int main()
{
	double x = -6.82, result;

	result = asinh(x);
	cout << ""asinh(x) = "" << result << "" radian"" << endl;

	// result in degrees
	cout << ""asinh(x) = "" << result*180/PI << "" degree"" << endl;

	return 0;
}","double asinh(double x);
float asinh(float x);
long double asinh(long double x);
double asinh(T x); // For integral type","The asinh() function takes a single mandatory argument whose inverse hyperbolic sine is to be computed.It can be any value i.e. negative, positive or zero.","asinh(x) = -2.61834 radian
asinh(x) = -150.02 degree",Cmath
acosh(),The acosh() function in C++ returns the arc hyperbolic cosine (inverse hyperbolic cosine) of a number in radians.,"#include <iostream>
#include <cmath>

#define PI 3.141592654
using namespace std;

int main()
{
	double x = 13.21, result;
	result = acosh(x);

	cout << ""acosh(x) = "" << result << "" radian"" << endl;

	// result in degrees
	cout << ""acosh(x) = "" << result*180/PI << "" degree"" << endl;

	return 0;
}","double acosh(double x);
float acosh(float x);
long double acosh(long double x);
double acosh(T x); // For integral type","The acosh() function takes a single mandatory argument which is greater or equal to 1.If the argument is less than 1, a domain error occurs.","acosh(x) = 3.27269 radian
acosh(x) = 187.511 degree",Cmath
fmod(),The fmod() function in C++ computes the floating point remainder of numerator/denominator (rounded towards zero),"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = 7.5, y = 2.1;
    double result = fmod(x, y);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;
    
    x = -17.50, y = 2.0;
    result = fmod(x, y);
    cout << ""Remainder of "" << x << ""/"" << y << "" = "" << result << endl;
    
    return 0;
}","double fmod(double x, double y);
float fmod(float x, float y);
long double fmod(long double x, long double y);
double fmod(Type1 x, Type2 y); // Additional overloads for other combinations of arithmetic types","x: The value of numerator.
y: The value of denominator.","Remainder of 7.5/2.1 = 1.2
Remainder of -17.5/2 = -1.5",Cmath
tanh(),The tanh() function in C++ returns the hyperbolic tangent of an angle given in radians.,"#include <iostream>
#include <cmath>
using namespace std;
int main()
{
	double x = 0.50, result;
	result = tanh(x);
	cout << ""tanh(x) = "" << result << endl;

	// x in Degrees
	double xDegrees = 90;
	x = xDegrees * 3.14159/180;

	result = tanh(x);
	cout << ""tanh(x) = "" << result << endl;

	return 0;
}","double tanh(double x);
float tanh(float x);
long double tanh(long double x);
double tanh(T x); // For integral type",The tanh() function takes a single mandatory argument representing a hyperbolic angle in radian.,"tanh(x) = 0.462117
tanh(x) = 0.917152",Cmath
floor(),The floor() function in C++ returns the largest possible integer value which is less than or equal to the given argument.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = 10.25, result;
    result = floor(x);
    cout << ""Floor of "" << x << "" = "" << result << endl;

    x = -34.251;
    result = floor(x);
    cout << ""Floor of "" << x << "" = "" << result << endl;
    
    x = 0.71;
    result = floor(x);
    cout << ""Floor of "" << x << "" = "" << result << endl;
    
    return 0;
}","double floor(double x);
float floor(float x);
long double floor(long double x);
double floor(T x); // For integral type",The floor() function takes a single argument whose floor value is computed.,"Floor of 10.25 = 10
Floor of -34.251 = -35
Floor of 0.71 = 0",Cmath
ceil(),The ceil() function in C++ returns the smallest possible integer value which is greater than or equal to the given argument.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x = 10.25, result;
    result = ceil(x);
    cout << ""Ceil of "" << x << "" = "" << result << endl;
    return 0;
}","double ceil(double x);
float ceil(float x);
long double ceil(long double x);
double ceil(T x); // For integral type",The ceil() function takes a single argument whose ceiling value is computed.,Ceil of 10.25 = 11,Cmath
sinh(),The sinh() function in C++ returns the hyperbolic sine of an angle given in radians.,"#include <iostream>
#include <cmath>
using namespace std;
int main()
{
    double x = 3.55, result;

    result = sinh(x);
    cout << ""sinh(x) = "" << result << endl;

    // x in Degrees
    double xDegrees = 90;
    x = xDegrees * 3.14159/180;

    result = sinh(x);
    cout << ""sinh(x) = "" << result << endl;

    return 0;
}","double sinh(double x);
float sinh(float x);
long double sinh(long double x);
double sinh(T x); // For integral type.",The sinh() function takes a single mandatory argument representing a hyperbolic angle in radian.,"sinh(x) = 17.3923
sinh(x) = 2.3013",Cmath
acos(),The acos() function in C++ returns the inverse cosine of a number (argument) in radians.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
  double x = 0.0, result;

  result = acos(x);
  cout << ""acos(x) = "" << result << "" radians"" << endl;
  
  // result in degrees
  cout << ""acos(x) = "" << result*180/3.1415 << "" degrees"" << endl;
  
  return 0;
}","double acos(double x);
float acos(float x);
long double acos(long double x);
double acos (T x); // For integral type","The acos() function takes a single mandatory argument in the range [-1, 1]. It is because the value of cosine is in the range of 1 and -1.","acos(x) = 1.5708 radians
acos(x) = 90.0027 degrees",Cmath
atan2(),The atan2() function in C++ returns the inverse tangent of a coordinate in radians.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
  double x = 10.0, y = -10.0, result;
  result = atan2(y, x);
  
  cout << ""atan2(y/x) = "" << result << "" radians"" << endl;
  cout << ""atan2(y/x) = "" << result*180/3.141592 << "" degrees"" << endl;
  
  return 0;
}","double atan2(double y, double x);
float atan2(float y, float x);
long double atan2(long double y, long double x);
double atan2(Type1 y, Type2 x); // For combinations of arithmetic types.","The function atan2() takes two arguments: x-coordinate and y-coordinate.x - this value represents the proportion of the x-coordinate.
y - this value represents the proportion of the y-coordinate.","atan2(y/x) = -0.785398 radians
atan2(y/x) = -45 degrees",Cmath
tan(),The tan() function in C++ returns the tangent of an angle (argument) given in radians.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{ 
  long double x = 0.99999, result;
  result = tan(x);
  cout << ""tan(x) = "" << result << endl;
  
  double xDegrees = 60.0;
  // converting degree to radians and using tan() fucntion
  result = tan(xDegrees*3.14159/180);
  cout << ""tan(x) = "" << result << endl;

  return 0;
}","double tan(double x);
float tan(float x);
long double tan(long double x);
double tan (T x); // For integral type","The tan() function takes a single mandatory argument in radians (can be positive, negative, or 0).","tan(x) = 1.55737
tan(x) = 1.73205",Cmath
atan(),The atan() function in C++ returns the inverse tangent of a number (argument) in radians.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
  double x = 57.74, result;
  result = atan(x);
  
  cout << ""atan(x) = "" << result << "" radians"" << endl;
  
  // Output in degrees
  cout << ""atan(x) = "" << result*180/3.1415 << "" degrees"" << endl;
  
  return 0;
}","double atan(double x);
float atan(float x);
long double atan(long double x);
double atan (T x); // For integral type","The atan() function takes a single mandatory argument (can be positive, negative, or zero)","atan(x) = 1.55348 radians
atan(x) = 89.0104 degrees",Cmath
asin(),The asin() function in C++ returns the inverse sine of a number in radian.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
  double x = 0.25, result;
  result = asin(x);
  
  cout << ""asin(x) = "" << result << "" radians"" << endl;
  // result in degrees
  cout << ""asin(x) = "" << result*180/3.1415 << "" degrees"" << endl;
  
  return 0;
}","double asin(double x);
float asin(float x);
long double asin(long double x);
double asin (T x);","The asin() function takes a single mandatory argument in the range [-1, 1].It is because the value of sine is in the range of 1 and -1.","asin(x) = 0.25268 radians
asin(x) = 14.4779 degrees",Cmath
sin(),The sin() function in C++ returns the sine of an angle (argument) given in radians.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
  double x = 0.439203, result;
  
  result = sin(x);
  cout << ""sin(x) = "" << result << endl;
  
  double xDegrees = 90.0;
  
  // converting degrees to radians
  x = xDegrees*3.14159/180;
  result = sin(x);
  
  cout << ""sin(x) = "" << result << endl;

  return 0;
}","double sin(double x);
float sin(float x);
long double sin(long double x);
double sin (T x); // For integral type",The sin() function takes a single mandatory argument in radians.,"sin(x) = 0.425218
sin(x) = 1",Cmath
cos(),The cos() function in C++ returns the cosine of an angle (argument) given in radian.,"#include <iostream>
#include <cmath>

using namespace std;

int main()
{
  double x = 0.5, result;
  
  result = cos(x);
  cout << ""cos(x) = "" << result << endl;
  
  double xDegrees = 25;
  
  // converting degrees to radians
  x = xDegrees*3.14159/180;
  result = cos(x);
  
  cout << ""cos(x) = "" << result << endl;

  return 0;
}","double cos(double x);
float cos(float x);
long double cos(long double x);
double cos(T x); // Here, T is an integral type.",The cos() function takes a single mandatory argument in radians.,"cos(x) = 0.877583
cos(x) = 0.906308",Cmath
calloc(),The calloc() function in C++ allocates a block of memory for an array of objects and initializes all its bits to zero.,"#include <cstdlib>
#include <iostream>
using namespace std;

int main() {
   int *ptr;
   ptr = (int *)calloc(5, sizeof(int));
   if (!ptr) {
      cout << ""Memory Allocation Failed"";
      exit(1);
   }
   cout << ""Initializing values..."" << endl
        << endl;
   for (int i = 0; i < 5; i++) {
      ptr[i] = i * 2 + 1;
   }
   cout << ""Initialized values"" << endl;
   for (int i = 0; i < 5; i++) {
      /* ptr[i] and *(ptr+i) can be used interchangeably */
      cout << *(ptr + i) << endl;
   }
   free(ptr);
   return 0;
}","void* calloc(size_t num, size_t size);","num: An unsigned integral value which represents number of elements.
size: An unsigned integral value which represents the memory block in bytes.","Initializing values...

Initialized values
1
3
5
7
9",Cstdlib
wcstombs(),The wcstombs() function in C++ converts a wide character string to equivalent multibyte sequence.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	wchar_t src[] = L""Welcome To Programiz.com"";
	char dest[50];
	int num;

	num = wcstombs(dest, src, 50);
	cout << ""Number of wide character converted = "" << num << endl;
	cout << ""Multibyte Character String = "" << dest << endl;
	
	return 0;
}","size_t wcstombs (char* dest, const wchar_t* src, size_t max);","dest: Pointer to the resulting multibyte character array.
src: Pointer to the first element of the wide character which is converted to multibyte character.
max: Maximum number of wide characters to be converted.","Number of wide character converted = 24
Multibyte Character String = Welcome To Programiz.com",Cstdlib
mbstowcs(),The mbstowcs() function in C++ converts a multibyte character string to equivalent wide character sequence.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	char src[] = ""\xc4\xe3\xba\xc3"";
	wchar_t dest[10];
	int num;

	num = mbstowcs(dest, src, MB_CUR_MAX);
	cout << ""Number of wide character converted = "" << num << endl;
	wcout << ""Wide Character String = "" << dest << endl;

	return 0;
}","size_t mbstowcs (wchar_t* dest, const char* src, size_t max);","dest: Pointer to the resulting wide character array.
src: Pointer to the first element of the multibyte character which is converted to wide character.
max: Maximum number of multibyte characters to be converted.","Number of wide character converted = 1
Wide Character String = ─",Cstdlib
wctomb(),The wctomb() function in C++ converts a wide character to a multibyte character.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	wchar_t wc = L'x';
	char *pmb1 = (char*)malloc(sizeof(char));
	char *pmb2 = NULL;
	int ret_val;

	cout << ""When pmb is not null"" << endl;
	ret_val = wctomb(pmb1, wc);

	cout << ""Return Value = "" << ret_val << endl;
	wcout << ""Multibyte Character: "" << pmb1 << endl << endl;

	cout << ""When pmb is null"" << endl;
	ret_val = wctomb(pmb2, wc);

	cout << ""Return Value = "" << ret_val << endl;
	wcout << ""Multibyte Character: "" << pmb2;
	
	return(0);
}","int wctomb (char* pmb, wchar_t wc);","pmb: Pointer to the resulting multibyte character
wc: Wide character that is converted to multibyte character","When pmb is not null
Return Value = 1
Multibyte Character: x↨R
When pmb is null
Return Value = 0
Multibyte Character:",Cstdlib
mbtowc(),The mbtowc() function in C++ converts a multibyte character to a wide character.,"#include <iostream>
#include <cstdlib>
#include <cstring>
using namespace std;

int main()
{
	char pmb[] = ""Welcome to Programiz.com"";
	wchar_t pwc[100];
	int len, ret_val;

	/* resets internal conversion state */
	mbtowc (NULL, NULL, 0);
	len = strlen(pmb);
	ret_val = mbtowc(pwc, pmb, strlen(pmb));

	cout << ""Return Value = "" << ret_val << endl;
	wcout << ""Wide character string: "" << pwc;

	return(0);
}","int mbtowc (wchar_t* pwc, const char* pmb, size_t max);","pwc: Pointer to the resulting wide character
pmb: Pointer to the multibyte character which is converted to wide character
max: Maximum size in bytes of pmb to consider for the multibyte character.","Return Value = 1
Wide character string: W@",Cstdlib
mblen(),The mblen() function in C++ determines the size (in bytes) of a multibyte character.,"#include <iostream>
#include <cstdlib>
#include <cstring>
using namespace std;

int main()
{
	int len;
	char *s = (char *)malloc(20);
	strcpy(s,""\xe4\xbd\xa0\xe5\xa5\xbd"");

	/* resets the conversion state */
	mblen(NULL, 0);
	len = mblen(s,strlen(s));

	cout << ""Length of multibyte character: "" << len << endl;
	return 0;
}","int mblen (const char* s, size_t max);","s: Pointer to the first byte of a multibyte character or a null pointer.
max: Maximum number of bytes in s that can be examined.",Length of multibyte character: 1,Cstdlib
lldiv(),The lldiv() function in C++ computes the integral quotient and remainder of the division of two numbers.,"struct lldiv_t {
	long long quot;
	long long rem;
};","lldiv_t lldiv(long long int x, long long int y);
lldiv_t lldiv(long long x, long long y);","x: Represents the numerator.
y: Represents the denominator.","Quotient of 998102910012/415 = 2405067253
Remainder of 998102910012/415 = 17",Cstdlib
llabs(),The llabs() function in C++ returns the absolute value of a long long int data.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	long long x,y;
	x = -79182028361LL;
	y = 129301730192LL;

	cout << ""llabs("" << x << "") = |"" << x << ""| = "" << llabs(x) << endl;
	cout << ""llabs("" << y << "") = |"" << y << ""| = "" << llabs(y) << endl;
	
	return 0;
}","long long llabs(long long x);
long long int llabs(long long int x);",x: A long long or long long int data whose absolute value is returned.,"llabs(-79182028361) = |-79182028361| = 79182028361
llabs(129301730192) = |129301730192| = 129301730192",Cstdlib
ldiv(),The ldiv() function in C++ computes the integral quotient and remainder of the division of two numbers.,"struct ldiv_t {
	long quot;
	long rem;
};","ldiv_t ldiv(long int x, long int y);
ldiv_t ldiv(long x, long y);","x: Represents the numerator.
y: Represents the denominator.","Quotient of 999810291/120 = 8331752
Remainder of 999810291/120 = 51",Cstdlib
labs(),The labs() function in C++ returns the absolute value of a long or long int data.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	long int x,y;
	x = -9999999L;
	y = 10000000L;

	cout << ""labs("" << x << "") = |"" << x << ""| = "" << labs(x) << endl;
	cout << ""labs("" << y << "") = |"" << y << ""| = "" << labs(y) << endl;

	return 0;
}","long labs(long x);
long int labs(long int x);",x: A long or long int data whose absolute value is returned.,"labs(-9999999) = |-9999999| = 9999999
labs(10000000) = |10000000| = 10000000",Cstdlib
abs(),The abs() function in C++ returns the absolute value of an integer number.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	int x = -5;
	long y = -2371041;

	int a = abs(x);
	long b = abs(y);

	cout << ""abs("" << x << "") = |"" << x << ""| = "" << a << endl;
	cout << ""abs("" << y << "") = |"" << y << ""| = "" << b << endl;
}","int abs(int x);
long abs(long x);
long long abs(long long x);",x: An integral value whose absolute value is returned.,"abs(-5) = |-5| = 5
abs(-2371041) = |-2371041| = 2371041",Cstdlib
div(),The div() function in C++ computes the integral quotient and remainder of the division of two numbers.,"div_t:
struct div_t {
	int quot;
	int rem;
};

ldiv_t:
struct ldiv_t {
	long quot;
	long rem;
};

lldiv_t:
struct lldiv_t {
	long long quot;
	long long rem;
};","div_t div(int x, int y);
ldiv_t div(long x, long y);
lldiv_t div(long long x, long long y);","x: Represents the numerator.
y: Represents the denominator.","Quotient of 51/6 = 8
Remainder of 51/6 = 3
Quotient of 19237012L/251L = 76641
Remainder of 19237012L/251L = 121",Cstdlib
qsort(),The qsort() function in C++ sorts a given array in ascending order using Quicksort algorithm.,"int compare(const void* a, const void* b);","void qsort (void* base, size_t num, size_t size, int (*compare)(const void*,const void*));","base: Pointer to the first element of the array to sort
num: Number of element in the array
size: Size in bytes of each element in the array
compare: A pointer to a function that that compares two elements. It returns
		
a negative integer if the first argument is less than the second
a positive integer if the first argument is greater than the second
zero if both arguments are equalThe prototype of the comparison function looks like:int compare(const void* a, const void* b);","Before sorting
9 4 19 2 7 9 5 15 23 3
After sorting
2 3 4 5 7 9 9 15 19 23",Cstdlib
bsearch(),The bsearch() function in C++ performs a binary search of an element in an array of elements and returns a pointer to the element if found.,"int compare(const void* a, const void* b);","void* bsearch (const void* key, const void* base, size_t num, size_t size, int (*compare)(const void*,const void*));","key: Pointer to the element to search
base: Pointer to the first element of the array
num: Number of element in the array
size: Size in bytes of each element in the array
compare: A pointer to a function that that compares two elements. It returns
		
a negative integer if the first argument is less than the second
a positive integer if the first argument is greater than the second
zero if both arguments are equalkey is passed as the first argument and an element from the array is passed as the second argument. The prototype of the comparison function looks like:int compare(const void* a, const void* b);","10 found at position 2
15 not found",Cstdlib
_Exit(),The _Exit() function in C++ causes normal termination of a process without performing any regular cleanup tasks.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	int exit_code;
	cout << ""Enter a value: "";
	cin >> exit_code;

	if (exit_code)
	{
		cout << ""Exiting using _Exit"";
		_Exit(exit_code);
	}
	else
	{
		cout << ""Exiting using exit"";
		exit(exit_code);
	}
}",void _Exit(int exit_code);,"exit_code: An integer value representing the exit status of the program.If exit_code is zero or EXIT_SUCCESS, it indicates successful termination.
If exit_code is non-zero or EXIT_FAILURE, it indicates failure.","Enter a value: 5
Exiting using _Exit",Cstdlib
quick_exit(),The quick_exit() function in C++ causes normal termination of a process without completely cleaning the resources.,"#include <iostream>
#include <cstdlib>
using namespace std;

void quick_exit1()
{
	cout << ""Exit Function 1"" << endl;
}
void quick_exit2()
{
	cout << ""Exit Function 2"" << endl;
}

int main()
{
	/* registering function */
	at_quick_exit(quick_exit1);
	at_quick_exit(quick_exit2);

	quick_exit(0);
	return 0;
}",void quick_exit(int exit_code);,"exit_code: An integer value representing the exit status of the program.If exit_code is zero or EXIT_SUCCESS, it indicates successful termination.
If exit_code is non-zero or EXIT_FAILURE, it indicates failure.","Exit Function 2
Exit Function 1",Cstdlib
getenv(),The getenv() function in C++ returns a pointer to a C string containing the value of the environment variable passed as argument.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	/* A list of possible environment variables*/
	const char *env_var[5] = {""PUBLIC"",""HOME"",""SESSIONNAME"",""LIB"",""SystemDrive""};
	char *env_val[5];

	for(int i=0; i<5; i++)
	{
		/* Getting environment value if exists */
		env_val[i] = getenv(env_var[i]);
		if (env_val[i] != NULL)
			cout << ""Variable = "" << env_var[i] << "", Value= "" << env_val[i] << endl;
		else
			cout << env_var[i] << "" doesn't exist"" << endl;
	}
}",char* getenv( const char* env_var );,env_var: C string containing the name of the environment variable.,"Variable = PUBLIC, Value= C:\Users\Public
HOME doesn't exist
Variable = SESSIONNAME, Value= Console
LIB doesn't exist
Variable = SystemDrive, Value= C:",Cstdlib
at_quick_exit(),The at_quick_exit() function in C++ registers a function to be called on quick program termination i.e. terminated via quick_exit().,"#include <iostream>
#include <cstdlib>
using namespace std;

void bye()
{
	cout << ""Program Exiting via quick_exit()"";
}

int main()
{
	at_quick_exit(bye);
	cout << ""Inside Main"" << endl;

	quick_exit(0);
	return 0;
}",extern int at_quick_exit (void (*func)(void));,func: Pointer to the function to be called on quick program termination.,"Inside Main
Program Exiting via quick_exit()",Cstdlib
atexit(),The atexit() function in C++ registers a function to be called on normal program termination.,"#include <iostream>
#include <cstdlib>
using namespace std;

void bye()
{
	cout << ""Program Exiting Successfully"";
}

int main()
{
	int x;
	x = atexit(bye);

	if (x != 0)
	{
		cout << ""Registration Failed"";
		exit(1);
	}

	cout << ""Registration successful"" << endl;
	return 0;
}",extern int atexit (void (*func)(void));,func: Pointer to the function to be called on normal program termination.,"Registration successful
Program Exiting Successfully",Cstdlib
realloc(),The realloc() function in C++ reallocates a block of memory that was previously allocated but not yet freed.,"#include <iostream>
#include <cstdlib>
using namespace std;
int main()
{
	float *ptr, *new_ptr;
	ptr = (float*) malloc(5*sizeof(float));
	if(ptr==NULL)
	{
		cout << ""Memory Allocation Failed"";
		exit(1);
	}

	/* Initializing memory block */
	for (int i=0; i<5; i++)
	{
		ptr[i] = i*1.5;
	}

	/* reallocating memory */
	new_ptr = (float*) realloc(ptr, 10*sizeof(float));
	if(new_ptr==NULL)
	{
		cout << ""Memory Re-allocation Failed"";
		exit(1);
	}
	
	/* Initializing re-allocated memory block */
	for (int i=5; i<10; i++)
	{
		new_ptr[i] = i*2.5;
	}
	cout << ""Printing Values"" << endl;
	
	for (int i=0; i<10; i++)
	{
		cout << new_ptr[i] << endl;
	}
	free(new_ptr);
	
	return 0;
}","void* realloc(void* ptr, size_t new_size);","ptr: A pointer to the memory block to be reallocated.
new_size: An unsigned integral value which represents the new size of the memory block in bytes.","Printing Values
0
1.5
3
4.5
6
12.5
15
17.5
20
22.5",Cstdlib
malloc(),The malloc() function in C++ allocates a block of uninitialized memory and returns a void pointer to the first byte of the allocated memory block if the allocation succeeds.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	int *ptr;
	ptr = (int*) malloc(5*sizeof(int));

	if(!ptr)
	{
		cout << ""Memory Allocation Failed"";
		exit(1);
	}
	cout << ""Initializing values..."" << endl << endl;

	for (int i=0; i<5; i++)
	{
		ptr[i] = i*2+1;
	}
	cout << ""Initialized values"" << endl;

	for (int i=0; i<5; i++)
	{
		/* ptr[i] and *(ptr+i) can be used interchangeably */
		cout << *(ptr+i) << endl;
	}

	free(ptr);
	return 0;
}",void* malloc(size_t size);,size: An unsigned integral value which represents the memory block in bytes.,"Initializing values...

Initialized values
1
3
5
7
9",Cstdlib
free(),"The free() function in C++ deallocates a block of memory previously allocated using calloc, malloc or realloc functions, making it available for further allocations.","#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	int *ptr;
	ptr = (int*) malloc(5*sizeof(int));
	cout << ""Enter 5 integers"" << endl;

	for (int i=0; i<5; i++)
	{
	// *(ptr+i) can be replaced by ptr[i]
		cin >> *(ptr+i);
	}
	cout << endl << ""User entered value""<< endl;

	for (int i=0; i<5; i++)
	{
		cout << *(ptr+i) << "" "";
	}
	free(ptr);

	/* prints a garbage value after ptr is free */
	cout << ""Garbage Value"" << endl;

	for (int i=0; i<5; i++)
	{
		cout << *(ptr+i) << "" "";
	}
	return 0;
}",void free(void *ptr);,"ptr: A pointer to a memory block previously allocated with malloc, calloc or realloc. The pointer may be null or may not point to a block of memory allocated by calloc, malloc or realloc functions.

		
If ptr is null, the free() function does nothing.
If ptr does not point to a memory block allocated by calloc, malloc or realloc functions, it causes undefined behavior.","Enter 5 integers
21 3 -10 -13 45
User entered value
21 3 -10 -13 45
Garbage Value
6690624 0 6685008 0 45",Cstdlib
srand(),The srand() function in C++ seeds the pseudo random number generator used by the rand() function.,"#include<iostream>
#include<cstdlib>
using namespace std;

int main()
{
	int random = rand();
	/* No srand() calls before rand(), so seed = 1*/
	cout << ""Seed = 1, Random number = "" << random << endl;

	srand(5);
	/* Seed = 5 */
	random = rand();
	cout << ""Seed = 5, Random number = "" << random << endl;

	return 0;
}",void srand(unsigned int seed);,seed: A seed value of type unsigned int,"Seed = 1, Random number = 41
Seed = 5, Random number = 54",Cstdlib
strtoull(),The strtoull() function in C++ interprets the contents of a string as an integral number of the specified base and return its value as an unsigned long long int.,"#include <iostream>
#include <cstdlib>
#include <cstring>
 
using namespace std;
 
int main()
{
 	int base = 10;
 	char numberString[] = ""231ax12"";
 	char *end;
 	unsigned long long int number;
 	
 	number = strtoull(numberString, &end, base);
 	cout << ""String value = "" << numberString << endl;
 	cout << ""Unsigned Long long int value = "" << number << endl;
 	cout << ""End String = "" << end << endl;
 	
 	strcpy(numberString, ""231"");
 	cout << ""String value = "" << numberString << endl;
 	number = strtoull(numberString, &end, base);
 	cout << ""Unsigned Long long int value = "" << number << endl;
 	if (*end) {
      	cout << end;
 	} else {
      	cout << ""Null pointer"";
 	}
 	return 0;
}","unsigned long long int strtoull(const char* str, char** end, int base);","str: A string having the representation of an integral number.
end: Reference to an already allocated object of type char*. The value of end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.
base: The base of the integral value. The set of valid values for base is {0, 2, 3, …, 35, 36}.","String value = 231ax12
Unsigned Long long int value = 231
End String = ax12
String value = 231
Unsigned Long long int value = 231
Null pointer",Cstdlib
strtoll(),The strtoll() function in C++ interprets the contents of a string as an integral number of the specified base and return its value as a long long int.,"#include <iostream>
#include <cstdlib>
#include <cstring>

using namespace std;

int main()
{
	int base = 10;
	char numberString[] = ""13.5ab_1x"";
	char *end; 
	long long int number;
	
	number = strtoll(numberString, &end, base);
	cout << ""String value = "" << numberString << endl;
	cout << ""Long long int value = "" << number << endl;
	cout << ""End String = "" << end << endl;
	
	strcpy(numberString, ""13"");
	cout << ""String value = "" << numberString << endl;
	number = strtoll(numberString, &end, base);
	cout << ""Long long int value = "" << number << endl;
	if (*end) {
		cout << end;
	} else {
		cout << ""Null pointer"";
	}
	return 0;
}","long long int strtoll(const char* str, char** end, int base);","str: A string having the representation of an integral number.
end: Reference to an already allocated object of type char*. The value of end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.
base: The base of the integral value. The set of valid values for base is {0, 2, 3, …, 35, 36}.","String value = 13.5ab_1x
Long long int value = 13
End String = .5ab_1x
String value = 13
Long long int value = 13
Null pointer",Cstdlib
atol(),The atol() function in C++ interprets the contents of a string and returns its corresponding integer value.,"#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
	char s[] = ""-114""; 
	double number;
	cout << ""Number in String = "" << s << endl;

	number = atol(s);
	cout << ""Number in Long Int = "" << number;
	
	return 0;
}",long int atol(const char* str);,str - A string having the representation of an integral number.,"Number in String = -114
Number in Long Int = -114",Cstdlib
strtol(),The strtol() function in C++ interprets the contents of a string as an integral number of the specified base and return its value as a long int.,"#include <iostream>
#include <cstdlib>

using namespace std;

int main()
{
    int base = 10;
    char str[] = ""27ab_1x"";
    char *end; 
    long int num;
    
    num = strtol(str, &end, base);
    cout << ""Number in  String = "" << str << endl;
    cout << ""Number in Long Int = "" << num << endl;
    cout << ""End String = "" << end << endl << endl;
    
    // the pointer to invalid characters can be null
    strcpy(str, ""27"");
    cout << ""Number in  String = "" << str << endl;
    num = strtol(str, &end, base);
    cout << ""Number in Long Int = "" << num << endl;
    if (*end) {
        cout << end;
    } else {
        cout << ""Null pointer"";
    }
    return 0;
}","long int strtol(const char* str, char** end, int base);","str: A string having the representation of an integral number.
end: Reference to an already allocated object of type char*. The value of end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.
base: The base of the integral value. The set of valid values for base is {0, 2, 3, …, 35, 36}.","Number in  String = 27ab_1x
Number in Long Int = 27
End String = ab_1x

Number in  String = 27
Number in Long Int = 27
Null pointer",Cstdlib
atof(),The atof() function in C++ interprets the contents of a string as a floating point number and return its value as a double.,"#include <iostream>
#include <cstdlib>

using namespace std;

int main()
{
	char numberString[] = ""-32.40""; 
	double numberInDouble;
	cout << ""Number in  String = "" << numberString << endl;

	numberInDouble = atof(numberString);
	cout << ""Number in Double = "" << numberInDouble;
	
	return 0;
}",double atof(const char* str);,str - A string having the representation of a floating point number.,"Number in  String = -32.40
Number in Double = -32.4",Cstdlib
strtod(),The strtod() function in C++ interprets the contents of a string as a floating point number and return its value as a double.,"#include <iostream>
#include <cstdlib>

using namespace std;

int main()
{
    char numberString[] = ""12.44b 0xy"";
    char *end;
    double number;

    number = strtod(numberString,&end);
    cout << ""Number in String = "" << numberString << endl;
    cout << ""Number in Double = "" << number << endl;
    cout << ""End String = "" << end << endl;

    return 0;
}","double strtod(const char* str, char** end);","str: A string having the representation of a floating point number.
end: Reference to an already allocated object of type char*. The value of end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.","Number in End String = 12.44b 0xy
Number in Double = 12.44
String = b 0xy",Cstdlib
wclog,The wclog object in C++ is an object of class wostream. It is associated with the standard C error output stream stderr.,extern ostream wclog;,extern ostream wclog;,"wclog and wcerr, both are associated with stderr, but it differs from wcerr in the sense that the streams in wclog are buffered and not automatically tied with wcout.Buffered output is more efficient than unbuffered output. In the case of buffered output, all the output is saved into a variable and written to disk all at once. For unbuffered output, we have to keep writing to disk.Buffered output isn't preferred for critical errors. In case of system crash, there can come a situation where the output was still in buffer and wasn't written to disk and the error message cannot be retrieved. We cannot afford to lose error data in case of system crash so we keep writing the critical errors to disc even though it is slower.wclog is commonly used for logging purposes. For non-critical event logging, efficiency is more important so wclog is preferred to wcerr.",Error while opening the file data.txt,Iostream
wcerr,The wcerr object in C++ is an object of class ostream. It is associated with the standard C error output stream stderr.,extern wostream wcerr;,extern wostream wcerr;,"Beginner C++ programmers use cout and wcout to display the error using standard output to debug their programs, but it is always good practice to use cerr and wcerr to display errors.This is because instead of showing the error stream to the screen, you can later change the error stream to write the errors to a file.",Error while opening the file data.txt,Iostream
wcout,The wcout object in C++ is an object of class wostream. It is used to display the output to the standard output device i.e. monitor. It is associated with the standard C output stream stdout.,extern wostream wcout;,extern wostream wcout;,"extern wostream wcout;It is defined in <iostream> header file.The wcout object is ensured to be initialized during or before the first time an object of type ios_base::Init is constructed. After the wcout object is constructed, it is tied to wcin which means that any input operation on wcin executes wcout.flush().The ""wc"" in wcout refers to ""wide character"" and 'out' means ""output"", hence wcout means ""wide character output"".The wcout object is used along with the insertion operator (<<) in order to display a stream of characters. The general syntax is:wcout << varName;orwcout << ""Some String"";The extraction operator can be used more than once with a combination of variables, strings and manipulators (like endl):wcout << var1 << ""Some String"" << var2 << endl;The wcout object can also be used with other member functions such as put(), write(), etc. Some of the commonly used member functions are:wcout.put(wchar_t &ch): Displays the wide character stored by ch.
wcout.write(wchar_t *str, int n): Displays the first n character reading from str.
wcout.setf(option): Sets a given option. Commonly used options are left, right, scientific, fixed, etc.
wcout.unsetf(option): Unsets a given option.
wcout.precision(int n): Sets the decimal precision to n while displaying floating-point values. Same as wcout << setprecision(n).","Enter 2 integers:4 9
Sum = 13
Enter a string:today
You entered today",Iostream
wcin,The wcin object in C++ is an object of class wistream. It is used to accept the input from the standard input device i.e. keyboard. It is associated with the standard C input stream stdin.,extern wistream wcin;,extern wistream wcin;,"extern wistream wcin;It is defined in <iostream> header file.The wcin object is ensured to be initialized during or before the first time an object of type ios_base::Init is constructed. After the wcin object is constructed, wcin.tie() returns &wcout which means that any formatted input operation on wcin forces a call to wcout.flush() if any characters are pending for output.The ""wc"" in wcin refers to ""wide character"" and 'in' means ""input"", hence wcin means ""wide character input"". The wcin object is used along with the extraction operator (>>) in order to receive a stream of characters. The general syntax is:wcin >> varName;The extraction operator can be used more than once to accept multiple inputs as:wcin >> var1 >> var2 >> … >> varN;The wcin object can also be used with other member functions such as getline(), read(), etc. Some of the commonly used member functions are:wcin.get(wchar_t &ch): Reads an wide character and store it in ch.
wcin.getline(wchar_t *buffer, int length): Reads a stream of wide characters into the string buffer, It stops when
		
it has read length-1 characters or
when it finds an end-of-line character ('\n') or the end of the file.


wcin.read(wchar_t *buffer, int n): Reads n bytes (or until the end of the file) from the stream into the buffer.
wcin.ignore(int n): Ignores the next n characters from the input stream.
wcin.eof(): Returns a nonzero value if the end of file (eof) is reached.","Enter a word: kathmandu
kathmandu",Iostream
cout,The cout object in C++ is an object of class ostream. It is used to display the output to the standard output device i.e. monitor. It is associated with the standard C output stream stdout.,"#include <iostream>

using namespace std;

int main()
{
	int a,b;
	char str[] = ""Hello Programmers"";
	
	/* Single insertion operator */
	cout << ""Enter 2 numbers - "";
	cin >> a >> b;
	cout << str;
	cout << endl;
	
	/* Multiple insertion operator */
	cout << ""Value of a is "" << a << endl << ""Value of b is "" << b;
	
	return 0;
}",extern ostream cout;,"#include <iostream>

using namespace std;

int main()
{
	int a,b;
	char str[] = ""Hello Programmers"";
	
	/* Single insertion operator */
	cout << ""Enter 2 numbers - "";
	cin >> a >> b;
	cout << str;
	cout << endl;
	
	/* Multiple insertion operator */
	cout << ""Value of a is "" << a << endl << ""Value of b is "" << b;
	
	return 0;
}When you run the program, a possible output will be:Enter 2 numbers - 6 17
Hello Programmers
Value of a is 6
Value of b is 17","Enter 2 numbers - 6 17
Hello Programmers
Value of a is 6
Value of b is 17",Iostream
strxfrm(),The strxfrm() function in C++ transforms a given null terminated byte string into an implementation defined form.,"#include <iostream>
#include <cstring>
#include <clocale>
using namespace std;
int main()
{
	setlocale(LC_COLLATE, ""cs_CZ.UTF-8"");
	const char* s1 = ""hrnec"";
	const char* s2 = ""chrt"";
	char t1[20], t2[20];

	cout << ""strcoll returned "" << strcoll(s1,s2) << endl;
	cout << ""Before transformation, "" << ""strcmp returned "" << strcmp(s1,s2) << endl;

	strxfrm(t1,s1,10);
	strxfrm(t2,s2,10);
	cout << ""After transformation, "" << ""strcmp returned "" << strcmp(t1,t2) << endl;

	return 0;
}","size_t strxfrm(char* dest, const char* src, size_t count);","dest: pointer to the array where the transformed string is stored.
src: pointer to the null terminated string to be transformed.
count: maximum number of characters to convert.","strcoll returned -1
Before transformation, strcmp returned 1
After transformation, strcmp returned -1",Cstring
strcoll(),The strcoll() function in C++ compares two null terminating string. The comparison is based on the current locale defined by the LC_COLLATE category.,"#include <cstring>
#include <iostream>
using namespace std;

int main()
{
	char lhs[] = ""Armstrong"";
	char rhs[] = ""Army"";
	int result;
	result = strcoll(lhs,rhs);

	cout << ""In the current locale "";
	if(result > 0)
		cout << rhs << "" precedes "" << lhs << endl;
	else if (result < 0)
		cout << lhs << "" precedes "" << rhs << endl;
	else
		cout << lhs << "" and "" << rhs << "" are same"" << endl;
		
	return 0;
}","int strcoll( const char* lhs, const char* rhs );",lhs and rhs: Pointer to the null terminated strings to compare.,In the current locale Armstrong precedes Army,Cstring
strlen(),The strlen() function in C++ returns the length of the given string.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char str1[] = ""This a string"";
    char str2[] = ""This is another string"";
    
    int len1 = strlen(str1);
    int len2 = strlen(str2);

    cout << ""Length of str1 = "" << len1 << endl;
    cout << ""Length of str2 = "" << len2 << endl;
    if (len1 > len2)
        cout << ""str1 is longer than str2"";
    else if (len1 < len2)
        cout << ""str2 is longer than str1"";
    else
        cout << ""str1 and str2 are of equal length"";

    return 0;
}",size_t strlen( const char* str );,str: Pointer to the null terminated byte string whose length is to be calculated.,"Length of str1 = 13
Length of str2 = 22
str2 is longer than str1",Cstring
strerror(),The strerror() function in C++ returns the textual description of the system error code.,"#include <cstring>
#include <cmath>
#include <cstdio>
#include <cerrno>
#include <iostream>

using namespace std;

int main()
{
    float log_neg = log(-2.5);
    cout << ""Log of negative number : "" << strerror(errno) << endl;

    /* example.txt does not exist */
    FILE * fp = fopen(""example.txt"",""r"");
    if (fp == NULL)
        cout << ""Error opening file : "" << strerror(errno) << endl;

    return 0;
}",char* strerror( int errnum );,errnum: An integer value representing the error code.,"Log of negative number : Numerical argument out of domain
Error opening file : No such file or directory",Cstring
memset(),The memset() function in C++ copies a single character for a specified number of time to an object.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char dest[50];
    char ch = 'a';
    memset(dest, ch, 20);

    cout << ""After calling memset"" << endl;
    cout << ""dest contains "" << dest; 
    return 0;
}","void* memset( void* dest, int ch, size_t count );","dest: Pointer to the object to copy the character.
ch: The character to copy.
count: Number of times to copy.","After calling memset
dest contains aaaaaaaaaaaaaaaaaaaa",Cstring
strtok(),The strtok() function in C++ returns the next token in a null terminated byte string.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char str[] = ""parrot,owl,sparrow,pigeon,crow"";
    char delim[] = "","";
    cout << ""The tokens are:"" << endl;
    char *token = strtok(str,delim);
    while (token)
    {
        cout << token << endl;
        token = strtok(NULL,delim);
    }
    return 0;
}","char* strtok( char* str, const char* delim );","str: Pointer to the null terminated byte string to tokenize.
delim: Pointer to the null terminated byte string that contains the separators.","The tokens are:
parrot
owl
sparrow
pigeon
crow",Cstring
strstr(),The strstr() function in C++ finds the first occurrence of a substring in a string.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char str[] = ""Use your brain and heart"";
    char target[] = ""brain"";
    char *p = strstr(str, target);
    
    if (p)
        cout << ""'"" << target << ""' is present in \"""" << str << ""\"" at position "" << p-str;
    else
        cout << target << "" is not present \"""" << str << ""\"""";

    return 0;
}","const char* strstr( const char* str, const char* target );
char* strstr( char* str, const char* target );","str: Pointer to the null terminated byte string to be searched for.
target: Pointer to the null terminated byte string to search for.","'brain' is present in ""Use your brain and heart"" at position 9",Cstring
strspn(),The strspn() function in C++ takes two string dest and src and gives the length of maximum initial segment of the string dest that consists of characters that are present in the string src.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char src[] = ""0123456789"";
    char dest[] = ""190126abqs121kfew"";
    
    size_t length = strspn(dest, src);

    cout << dest << "" contains "" << length << "" initial numbers"";
    return 0;
}","size_t strspn( const char* dest, const char* src );","dest: Pointer to the null terminated byte string to be searched for.
src: Pointer to the null terminated byte string that contains the characters to search for.",190126abqs121kfew contains 6 initial numbers,Cstring
strrchr(),The strrchr() function in C++ searches for the last occurrence of a character in a string.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char str[] = ""Hello World!"";
    char ch = 'o';
    char *p = strrchr(str, ch);
    
    if (p)
        cout << ""Last position of "" << ch << "" in \"""" << str << ""\"" is "" << p-str;
    else
        cout << ch << "" is not present \"""" << str << ""\"""";

    return 0;
}","const char* strrchr( const char* str, int ch );
char* strrchr( char* str, int ch );","ptr: Pointer to the null terminated string to be searched for.
ch: Character to search for.","Last position of o in ""Hello World!"" is 7",Cstring
strpbrk(),The strpbrk() function in C++ searches for a set of characters present in a string in another string.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    char digits[] = ""0123456789"";
    char code[] = ""ceQasieoLPqa4xz10Iyq"";
    char *pos;
    int count = 0;

    pos = strpbrk (code, digits);
    while (pos != NULL)
    {
        pos = strpbrk (pos+1,digits);
        count ++;
    }

    cout << ""There are "" << count << "" numbers in "" << code;

    return 0;
}","const char* strpbrk( const char* dest, const char* breakset );
char* strpbrk( char* dest, const char* breakset );","dest: Pointer to a null terminated string to be searched.
breakset: Pointer to a null terminated string containing the characters to search for.",There are 3 numbers in ceQasieoLPqa4xz10Iyq,Cstring
strcspn(),The strcspn() function in C++ takes two null terminated byte string: dest and src as its argument and searches dest for any characters that is present in src.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char num[] = ""0123456789"";
    char code[] = ""ceQasieoLPqa4xz10Iyq"";

    size_t result = strcspn(code, num);

    if (result < strlen(code))
        cout << ""First occurrence of number in "" << code << "" is at position "" << result;
    else
        cout << code << "" does not contain numbers"";

    return 0;
}","size_t strcspn( const char *dest, const char *src );","dest: Pointer to a null terminated string to be searched.
src: Pointer to a null terminated string containing the characters to search for.",First occurrence of number in ceQasieoLPqa4xz10Iyq is at position 12,Cstring
strchr(),The strchr() function in C++ searches for the first occurrence of a character in a string.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char str[] = ""Programming is easy."";
    char ch = 'r';
    
    if (strchr(str, ch))
        cout << ch << "" is present \"""" << str << ""\"""";
    else
        cout << ch << "" is not present \"""" << str << ""\"""";

    return 0;
}","const char* strchr( const char* str, int ch );
char* strchr( char* str, int ch );","ptr: Pointer to the null terminated string to be searched for.
ch: Character to search for.","r is present ""Programming is easy.""",Cstring
memchr(),The memchr() function in C++ searches for the first occurrence of a character in a specified number of characters.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char ptr[] = ""This is a random string"";
    char ch = 'r';
    int count = 15;
    
    if (memchr(ptr,ch, count))
        cout << ch << "" is present in first "" << count << "" characters of \"""" << ptr << ""\"""";
    else
        cout << ch << "" is not present in first "" << count << "" characters of \"""" << ptr << ""\"""";

    return 0;
}","const void* memchr( const void* ptr, int ch, size_t count );
void* memchr( void* ptr, int ch, size_t count );","ptr: Pointer to the object to be searched for.
ch: Character to search for.
count: Number of character to be searched for.","r is present in first 15 characters of ""This is a random string""",Cstring
strncmp(),The strncmp() function in C++ compares a specified number of characters of two null terminating strings. The comparison is done lexicographically.,"#include <cstring>
#include <iostream>

using namespace std;

void display(char *lhs, char *rhs, int result, int count)
{
    if(result > 0)
        cout << rhs << "" precedes "" << lhs << endl;
    else if (result < 0)
        cout << lhs << "" precedes "" << rhs << endl;
    else
        cout << ""First "" << count << "" characters of "" << lhs << "" and "" << rhs << "" are same"" << endl;
}

int main()
{
    char lhs[] = ""Armstrong"";
    char rhs[] = ""Army"";
    int result;

    result = strncmp(lhs,rhs,3);
    display(lhs,rhs,result,3);

    result = strncmp(lhs,rhs,4);
    display(lhs,rhs,result,4);

    return 0;
}","int strncmp( const char* lhs, const char* rhs, size_t count );","lhs and rhs: Pointer to the null terminated strings to compare.
count: Maximum number of characters to compare.","First 3 characters of Armstrong and Army are same
Armstrong precedes Army",Cstring
strcmp(),The strcmp() function in C++ compares two null terminating string. The comparison is done lexicographically.,"#include <cstring>
#include <iostream>

using namespace std;

void display(char *lhs, char *rhs, int result)
{
    if(result > 0)
        cout << rhs << "" precedes "" << lhs << endl;
    else if (result < 0)
        cout << lhs << "" precedes "" << rhs << endl;
    else
        cout << lhs << "" and "" << rhs << "" are same"" << endl;
}

int main()
{
    char lhs[] = ""Armstrong"";
    char rhs[] = ""Army"";
    int result;

    result = strcmp(lhs,rhs);
    display(lhs,rhs,result);

    result = strcmp(lhs,lhs);
    display(lhs,lhs,result);

    return 0;
}","int strcmp( const char* lhs, const char* rhs );",lhs and rhs: Pointer to the null terminated strings to compare.,"Armstrong precedes Army
Armstrong and Armstrong are same",Cstring
memcmp(),The memcmp() function in C++ compares a specified number of characters of two pointer objects,"#include <cstring>
#include <iostream>

using namespace std;

void display(char *lhs, char *rhs, int result, int count)
{
    if(result > 0)
        cout << rhs << "" precedes "" << lhs << endl;
    else if (result < 0)
        cout << lhs << "" precedes "" << rhs << endl;
    else
        cout << ""First "" << count << "" characters of "" << lhs << "" and "" << rhs << "" are same"" << endl;
}

int main()
{
    char lhs[] = ""Hello World!"";
    char rhs[] = ""Hello Earth!"";
    int result;

    result = memcmp(lhs, rhs, 5);
    display(lhs, rhs, result, 5);
    
    result = memcmp(lhs, rhs, 7);
    display(lhs, rhs, result, 7);
    return 0;
}","int memcmp( const void* lhs, const void* rhs, size_t count );","lhs and rhs: Pointer to the memory objects to compare.
count: Maximum numbers of bytes to compare.","First 5 characters of Hello World! and Hello Earth! are same
Hello Earth! precedes Hello World!",Cstring
strncat(),The strncat() function in C++ appends a specified number of characters of a string to the end of another string.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char dest[50] = ""Using strncat function,"";
    char src[50] = "" this part is added and this is ignored"";

    strncat(dest, src, 19);
    
    cout << dest ;

    return 0;

}","char* strncat( char* dest, const char* src, size_t count );","dest: Pointer to a null terminating string to append to.
src: Pointer to a null terminating string that is to be appended.
count: Maximum numbers of characters to copy.","Using strncat function, this part is added",Cstring
strcat(),The strcat() function in C++ appends a copy of a string to the end of another string.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char dest[50] = ""Learning C++ is fun"";
    char src[50] = "" and easy"";

    strcat(dest, src);
    
    cout << dest ;

    return 0;

}","char* strcat( char* dest, const char* src );","dest: Pointer to a null terminating string to append to.
src: Pointer to a null terminating string that is to be appended.",Learning C++ is fun and easy,Cstring
strncpy(),C++ strncpy() function The strncpy() function in C++ copies a specified bytes of characters from source to destination.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char src[] = ""It's Monday and it's raining"";
    char dest[40];

    /* count less than length of src */
    strncpy(dest,src,10);
    cout << dest << endl;

    /* count more than length of src */
    strncpy(dest,src,strlen(src)+10);
    cout << dest << endl;
    return 0;
}","char* strncpy( char* dest, const char* src, size_t count );","dest: Pointer to a character array where the contents are copied to.
src: Pointer to a character array where the contents are copied from.
count: Maximum number of characters to copy.","It's Monday
It's Monday and it's raining",Cstring
strcpy(),The strcpy() function in C++ copies a character string from source to destination.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    char src[] = ""Hello Programmers."";
    
    /* Large enough to store content of src */
    char dest[20];
    
    strcpy(dest,src);
    cout << dest;
    return 0;
}","char* strcpy( char* dest, const char* src );","dest: Pointer to a character array where the contents are copied to.
src: Pointer to a character array where the contents are copied from.",Hello Programmers.,Cstring
memmove(),The memmove() function in C++ copies a specified bytes of data from source to the destination.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    int arr[10] = {8,3,11,61,-22,7,-6,2,13,47};
    int *new_arr = &arr[5];

    memmove(new_arr,arr,sizeof(int)*5);

    cout << ""After copying"" << endl;
    for (int i=0; i<10; i++)
        cout << arr[i] << endl;
    return 0;

}","void* memmove( void* dest, const void* src,size_t count );","dest: Pointer to the memory location where the contents are copied to
src: Pointer to the memory location where the contents are copied from.
count: Number of bytes to copy from src to dest.",After copying 8 3 11 61 -22 8 3 11 61 -22,Cstring
memcpy(),The memcpy() function in C++ copies a specified bytes of data from source to the destination.,"#include <cstring>
#include <iostream>

using namespace std;

int main()
{
    int arr[10] = {8,3,11,61,-22,7,-6,2,13,47};
    int new_arr[5];

    memcpy(new_arr,arr,sizeof(int)*5);
    cout << ""After copying"" << endl;
    for (int i=0; i<5; i++)
        cout << new_arr[i] << endl;
    return 0;
}","void* memcpy( void* dest, const void* src,size_t count );","dest: Pointer to the memory location where the contents are copied to
src: Pointer to the memory location where the contents are copied from.
count: Number of bytes to copy from src to dest.","After copying
8
3
11
61
-22",Cstring
toupper(),The toupper() function in C++ converts a given character to uppercase.,"#include <cctype>
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

int main()
{
    char str[] = ""John is from USA."";

    cout << ""The uppercase version of \"""" << str << ""\"" is "" << endl;

    for (int i=0; i<strlen(str); i++)
        putchar(toupper(str[i]));
    
    return 0;
}",int toupper(int ch);,ch: The character to convert,"The uppercase version of ""John is from USA."" is 
JOHN IS FROM USA.",Cctype
tolower(),The tolower() function in C++ converts a given character to lowercase.,"#include <cctype>
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

int main()
{
    char str[] = ""John is from USA."";

    cout << ""The lowercase version of \"""" << str << ""\"" is "" << endl;

    for (int i=0; i<strlen(str); i++)
        putchar(tolower(str[i]));
    
    return 0;
}",int tolower(int ch);,ch: The character to convert,"The lowercase version of ""John is from USA."" is 
john is from usa.",Cctype
isxdigit(),The isxdigit() function in C++ checks if the given character is a hexadecimal character or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    bool flag = 0;
    char str[] = ""50Af"";

    for (int i=0; i<strlen(str); i++)
    {
        if (!isxdigit(str[i]))
        {
            flag = 1;
            break;
        }
    }

    if (flag)
        cout << str << "" is not a valid hexadecimal number"";
    else
        cout << str << "" is a valid hexadecimal number"";
    
    return 0;
}",int isxdigit(int ch);,ch: The character to check.,50Af is a valid hexadecimal number,Cctype
isupper(),The isupper() function in C++ checks if the given character is a uppercase character or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char str[] = ""This Program Converts ALL UPPERCASE Characters to LOWERCASE"";

    for (int i=0; i<strlen(str); i++)
    {
        if (isupper(str[i]))
            /*  Converting uppercase characters to lowercase  */
            str[i] = str[i] + 32;
    }

    cout << str;
    return 0;
}",int isupper(int ch);,ch: The character to check.,this program converts all uppercase characters to lowercase,Cctype
isspace(),The isspace() function in C++ checks if the given character is a whitespace character or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char str[] = ""<html>\n<head>\n\t<title>C++</title>\n</head>\n</html>"";

    cout << ""Before removing whitespace characters"" << endl;
    cout << str << endl << endl;

    cout << ""After removing whitespace characters"" << endl;
    for (int i=0; i<strlen(str); i++)
    {
        if (!isspace(str[i]))
            cout << str[i];
    }
    
    return 0;
}",int isspace(int ch);,ch: The character to check.,"Before removing whitespace characters
<html>
<head>
	<title>C++</title>
<head>
<html>

After removing whitespace characters
<html><head><title>C++</title></head></html>",Cctype
ispunct(),The ispunct() function in C++ checks if the given character is a punctuation character or not.,"#include <cctype>
#include <iostream>

using namespace std;

int main()
{
    char ch1 = '+';
    char ch2 = 'r';

    ispunct(ch1) ? cout << ch1 << "" is a punctuation character"" : cout << ch1 << "" is not a punctuation character"";
    cout << endl;
    ispunct(ch2) ? cout << ch2 << "" is a punctuation character"" : cout << ch2 << "" is not a punctuation character"";

    return 0;
}",int ispunct(int ch);,ch: The character to check.,"+ is a punctuation character
r is not a punctuation character",Cctype
isprint(),The isprint() function in C++ checks if the given character is printable or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char str[] = ""Hello\tall\nhow are you"";

    for (int i=0; i<strlen(str); i++)
    {
        /* replace all non printable character by space */
        if (!isprint(str[i]))
            str[i] = ' ';
    }

    cout << str;
    return 0;
}",int isprint(int ch);,ch: The character to check.,Hello all how are you,Cctype
islower(),The islower() function in C++ checks if the given character is a lowercase character or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char str[] = ""This Program Converts ALL LowerCase Characters to UpperCase"";

    for (int i=0; i < strlen(str); i++)
    {
        if (islower(str[i]))
            /*  Converting lowercase characters to uppercase  */
            str[i] = str[i] - 32;
    }

    cout << str;
    return 0;
}",int islower(int ch);,ch: The character to check.,THIS PROGRAM CONVERTS ALL LOWERCASE CHARACTERS TO UPPERCASE,Cctype
isgraph(),The isgraph() function in C++ checks if the given character is graphic or not.,"#include <cctype>
#include <iostream>

using namespace std;

int main()
{
    char ch1 = '$';
    char ch2 = '\t';

    isgraph(ch1)? cout << ch1 << "" has graphical representation"" : cout << ch1 << "" does not have graphical representation"";
    cout << endl;
    isgraph(ch2)? cout << ch2 << "" has graphical representation"" : cout << ch2 << "" does not have graphical representation"";

    return 0;
}",int isgraph(int ch);,ch: The character to check.,"$ has graphical representation
    does not have graphical representation",Cctype
isdigit(),The isdigit() function in C++ checks if the given character is a digit or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char str[] = ""hj;pq910js4"";

    cout << ""The digit in the string are:"" << endl;
    for (int i=0; i<strlen(str); i++)
    {
        if (isdigit(str[i]))
            cout << str[i] << "" "";
    }

    return 0;
}",int isdigit(int ch);,ch: The character to check.,"The digit in the string are:
9 1 0 4",Cctype
iscntrl(),The iscntrl() function in C++ checks if the given character is a control character or not.,"#include <cctype>
#include <iostream>

using namespace std;

int main()
{
    char ch1 = '\t';
    char ch2 = 'x';

    iscntrl(ch1)?cout << ch1 << "" is a control character"":cout << ch1 << "" is not a control character"";
    cout << endl;
    iscntrl(ch2)?cout << ch2 << "" is a control character"":cout << ch2 << "" is not a control character"";
        
    return 0;
}",int iscntrl(int ch);,ch: The character to check.,"is a control character
x is not a control character",Cctype
isblank(),The isblank() function in C++ checks if the given character is a blank character or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char str[] = ""Hello, I am here."";
    int count = 0;

    for (int i=0; i<=strlen(str); i++)
    {
        if (isblank(str[i]))
            count ++;
    }

    cout << ""Number of blank characters: "" << count << endl;

    return 0;
}",int isblank(int ch);,ch: The character to check.,Number of blank characters: 3,Cctype
isalpha(),The isalpha() function in C++ checks if the given character is an alphabet or not.,"#include <cctype>
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char str[] = ""ad138kw+~!$%?';]qjj"";
    int count = 0;

    for (int i=0; i<=strlen(str); i++)
    {
        if (isalpha(str[i]))
            count ++;
    }

    cout << ""Number of alphabet characters:"" << count << endl;
    cout << ""Number of non alphabet characters:"" << strlen(str)-count << endl;

    return 0;
}",int isalpha(int ch);,ch: The character to check.,"Number of alphabet characters:7
Number of non alphabet characters:12",Cctype
raise(),The raise() function in C++ sends signal to the program.,"#include <iostream>
#include <csignal>
 
using namespace std;

sig_atomic_t sig_value = 0;

void handler(int sig)
{
    sig_value = sig;
}

int main()
{
    signal(SIGABRT, handler);
    cout << ""Before signal handler is called"" << endl;
    cout << ""Signal = "" << sig_value << endl; 
    raise(SIGABRT);
    cout << ""After signal handler is called"" << endl;
    cout << ""Signal = "" << sig_value << endl;

    return 0;
}",int raise( int sig );,"sig: The signal to be sent for handling. It can take one of the following values:SIGABRT
SIGFPE
SIGILL
SIGINT
SIGSEGV
SIGTERM","Before signal handler is called
Signal = 0
After signal handler is called
Signal = 6",Csignal
signal(),The signal() function in C++ sets the error handler for the specified signal.,void fun(int sig);,"void (*signal (int sig, void (*func)(int)))(int);","sig: The signal to handle by the signal handler. It can take one of the following values:

		
SIGABRT
SIGFPE
SIGILL
SIGINT
SIGSEGV
SIGTERM


handler: The signal handler that handles the signal. It can be one of the following:
		
SIG_DFL: Default handling.
SIG_IGN: Ignore the signal.
Pointer to a function: User defined function to handle the signal. The signature of the function must be equivalent to the following:
				
void fun(int sig);",Signal is handled,Csignal
localeconv(),The localeconv() function in C++ returns an object that represents numeric and monetary formatting rules of the current C locale.,"#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	lconv *l;

	setlocale(LC_MONETARY, ""en_GB.utf8"");
	l = localeconv();
	cout << ""Locale Currency Symbol = "" << l->currency_symbol << endl;
	cout << ""International Currency Symbol = "" << l->int_curr_symbol << endl;

	setlocale(LC_MONETARY, ""en_US.utf8"");
	l = localeconv();
	cout << ""Locale Currency Symbol = "" << l->currency_symbol << endl;
	cout << ""International Currency Symbol = "" << l->int_curr_symbol << endl;
	
	return 0;
}",lconv* localeconv();,None,"Locale Currency Symbol = £
International Currency Symbol = GBP
Locale Currency Symbol = $
International Currency Symbol = USD",Clocale
setlocale(),The setlocale() function in C++ sets the locale information for the current program.,"#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	char *str;
	setlocale(LC_ALL, ""en_US.utf8"");
	
	str = setlocale(LC_ALL, NULL);
	cout << ""Current locale: "" << str << endl;
	cout << ""Changing locale "" << endl;
	
	setlocale(LC_ALL, ""en_GB.utf8"");
	str = setlocale(LC_ALL, NULL);
	wcout << ""Current locale: "" << str << endl;
	
	return 0;
}","int setlocale(int category, const char* locale);","category: Specifies which locale information of the program is affected. The possible macros for category are:Category macro for setlocale()


Macros
Description




LC_ALL
Selects all the C locale


LC_COLLATE
Selection the collation category


LC_CTYPE
Selects the character classification category


LC_MONETARY
Selects the monetary formatting category


LC_NUMERIC
Selects the numeric formatting category


LC_TIME
Selects the time formatting categorylocale: A system specific locale identifier. If it is a null pointer, a call to setlocale() queries the current C locale.","Current locale: en_US.utf8
Changing locale
Current locale: en_GB.utf8",Clocale
iswdigit(),The iswdigit() function in C++ checks if the given wide character is a digit or not.,"#include <cwctype>
#include <iostream>
#include <cwchar>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t str[] = L""\u20b9\u0967\u0966 = Rs.10"";

	wcout << L""The digit in the string \"""" << str << L""\"" are :"" << endl;
	for (int i=0; i<wcslen(str); i++)
	{
		if (iswdigit(str[i]))
		wcout << str[i] << "" "";
	}
	
	return 0;
}",int iswdigit(wint_t ch);,ch: The wide character to check.,"The digit in the string ""₹१० = Rs.10"" are :
1 0",Cwctype
wctype(),The wctype() function in C++ returns a value of type wctype_t that is used for wide character classification.,"#include <cwctype>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t wc = L'\u00b5';

	if (iswctype(wc, wctype(""digit"")))
		wcout << wc << L"" is a digit"";
	else if (iswctype(wc, wctype(""alpha"")))
		wcout << wc << L"" is an alphabet"";
	else
		wcout << wc << L"" is neither an alphabet nor a digit"";
		
	return 0;
}",wctype_t wctype(const char* str);,"str: C string specifying the desired category.Value of str for wctype


Value of str
Equivalent function




alnum
iswalnum


alpha
iswalpha


blank
iswblank


cntrl
iswcntrl


digit
iswdigit


graph
iswgraph


lower
iswlower


print
iswprint


punct
iswpunct


space
iswspace


xdigit
iswxdigit


upper
iswupper",µ is an alphabet,Cwctype
wctrans(),The wctrans() function in C++ returns a value of type wctrans_t that corresponds to the transformation.,"#include <cwctype>
#include <iostream>
#include <cwchar>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");

	wchar_t str[] = L""Ŝŵitĉhiňģ Ćăse"";
	wcout << L""Before transformation"" << endl;
	wcout << str << endl;

	for(int i=0; i<wcslen(str); i++)
	{
		if (iswctype(str[i], wctype(""lower"")))
		str[i] = towctrans(str[i], wctrans(""toupper""));
		else if (iswctype(str[i], wctype(""upper"")))
		str[i] = towctrans(str[i], wctrans(""tolower""));
	}

	wcout << L""After transformation"" << endl;
	wcout << str << endl;
	
	return 0;
}",wctrans_t wctrans(const char* str);,str: C string specifying the desired transformation.,"Before transformation
Ŝŵitĉhiňģ Ćăse
After transformation
ŝŴITĈHIŇĢ ćĂSE",Cwctype
towctrans(),The towctrans() function in C++ transforms a given wide character according to a specified transformation.,"#include <cwctype>
#include <iostream>
#include <cwchar>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t str[] = L""Ŝŵitĉhiňģ Ćăse"";
	wcout << L""Before transformation"" << endl;
	wcout << str << endl;

	for(int i=0; i<wcslen(str); i++)
	{
		if (iswctype(str[i], wctype(""lower"")))
		str[i] = towctrans(str[i], wctrans(""toupper""));
		else if (iswctype(str[i], wctype(""upper"")))
		str[i] = towctrans(str[i], wctrans(""tolower""));
	}

	wcout << L""After transformation"" << endl;
	wcout << str << endl;
	
	return 0;
}","wint_t towctrans(wint_t wc, wctype_t desc);","wc: The wide character to be transformed.
desc: The transformation which is obtained from a call to wctrans().","Before transformation
Ŝŵitĉhiňģ Ćăse
After transformation
ŝŴITĈHIŇĢ ćĂSE",Cwctype
towupper(),The towupper() function in C++ converts a given wide character to uppercase.,"#include <cwctype>
#include <cwchar>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t str[] = L""Ĵōhn Deńvėr"";
	wcout << L""The uppercase version of \"""" << str << L""\"" is "";
	
	for (int i=0; i<wcslen(str); i++)
		putwchar(towupper(str[i]));
	
	return 0;
}",wint_t towupper( wint_t ch );,ch: The wide character to convert,"The uppercase version of ""Ĵōhn Deńvėr"" is ĴŌHN DEŃVĖR",Cwctype
towlower(),The towlower() function in C++ converts a given wide character to lowercase.,"#include <cwctype>
#include <cwchar>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");

	wchar_t str[] = L""Ĵōhn Deńvėr"";
	wcout << L""The lowercase version of \"""" << str << L""\"" is "";

	for (int i=0; i<wcslen(str); i++)
		putwchar(towlower(str[i]));

	return 0;
}",wint_t towlower( wint_t ch );,ch: The wide character to convert,"The lowercase version of ""Ĵōhn Deńvėr"" is ĵōhn deńvėr",Cwctype
iswupper(),The iswupper() function in C++ checks if the given wide character is a uppercase character or not.,"#include <cwctype>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t ch1 = L'\u03a0';
	wchar_t ch2 = L'\u03c0';
	
	wcout << L""iswupper("" << ch1 << "") returned "" << boolalpha << (bool)iswupper(ch1) << endl;
	wcout << L""iswupper("" << ch2 << "") returned "" << boolalpha << (bool)iswupper(ch2) << endl;
	
	return 0;
}",int iswupper(wint_t ch);,ch: The wide character to check.,"iswupper(Π) returned true
iswupper(π) returned false",Cwctype
iswspace(),The iswspace() function in C++ checks if the given wide character is a wide whitespace character or not.,"#include <cwctype>
#include <iostream>
#include <cwchar>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t str[] = L""<html>\n<head>\n\t<title>\u0939\u0947\u0932\u094b</title>\n</head>\n</html>"";

	wcout << L""Before removing whitespace characters"" << endl;
	wcout << str << endl << endl;
	wcout << L""After removing whitespace characters"" << endl;

	for (int i=0; i<wcslen(str); i++)
	{
		if (!iswspace(str[i]))
			wcout << str[i];
	}
	
	return 0;
}",int iswspace(wint_t ch);,ch: The wide character to check.,"Before removing whitespace characters
<html>
<head>
<title>हेलो</title>
</head>
</html>
After removing whitespace characters
<html><head><title>हेलो</title></head></html>",Cwctype
iswpunct(),The iswpunct() function in C++ checks if the given wide character is a punctuation or not.,"#include <cwctype>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t ch1 = L'\u0938';
	wchar_t ch2 = L'\u007e';
	
	iswpunct(ch1) ? wcout << ch1 << L"" is a punctuation character"" : wcout << ch1 << L"" is not a punctuation character"";
	wcout << endl;
	iswpunct(ch2) ? wcout << ch2 << L"" is a punctuation character"" : wcout << ch2 << L"" is not a punctuation character"";
	
	return 0;
}",int iswpunct(wint_t ch);,ch: The wide character to check.,"स is not a punctuation character
~ is a punctuation character",Cwctype
iswlower(),The iswlower() function in C++ checks if the given wide character is a lowercase character or not.,"#include <cwctype>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");

	wchar_t ch1 = L'\u03a0';
	wchar_t ch2 = L'\u03c0';

	wcout << L""islower("" << ch1 << "") returned "" << boolalpha << (bool)iswlower(ch1) << endl;
	wcout << L""islower("" << ch2 << "") returned "" << boolalpha << (bool)iswlower(ch2) << endl;

	return 0;
}",int iswlower(wint_t ch);,ch: The wide character to check.,"islower(Π) returned false
islower(π) returned true",Cwctype
iswgraph(),The iswgraph() function in C++ checks if the given wide character has a graphical representation or not.,"#include <cwctype>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t ch1 = L'\u0009';
	wchar_t ch2 = L'\u03a9';
	
	iswgraph(ch1)? wcout << ch1 << L"" has graphical representation"" : wcout << ch1 << L"" does not have graphical representation"";
	wcout << endl;
	iswgraph(ch2)? wcout << ch2 << L"" has graphical representation"" : wcout << ch2 << L"" does not have graphical representation"";

	return 0;
}",int iswgraph(wint_t ch);,ch: The wide character to check.,"does not have graphical representation
Ω has graphical representation",Cwctype
iswcntrl(),The iswcntrl() function in C++ checks if the given wide character is a control character or not.,"#include <cwctype>
#include <iostream>
using namespace std;

int main()
{
	wchar_t ch1 = L'\u000c';// unicode for form feed
	wchar_t ch2 = L'\u03a3';// unicode for Σ
	
	cout << hex << showbase << boolalpha << ""iswcntrl("" << (wint_t)ch1 << "") returned "" << (bool)iswcntrl(ch1) << endl;
	cout << hex << showbase << boolalpha << ""iswcntrl("" << (wint_t)ch2 << "") returned "" << (bool)iswcntrl(ch2) << endl;

	return 0;
}",int iswcntrl(wint_t ch);,ch: The wide character to check.,"iswcntrl(0xc) returned true
iswcntrl(0x3a3) returned false",Cwctype
iswblank(),The iswblank() function in C++ checks if the given wide character is a blank character or not.,"#include <cwctype>
#include <iostream>
#include <cwchar>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t str[] = L""\u0757\u077c\u0020\u00c5\u00d5\u00dd\u0009\u00a5"";
	int count = 0;
	for (int i=0; i<wcslen(str); i++)
	{
		if (iswblank(str[i]))
		count ++;
	}

	wcout << L""Number of blank characters in \"""" << str << ""\"" = "" << count;
	return 0;
}",int iswblank(wint_t ch);,ch: The wide character to check.,"Number of blank characters in ""ݗݼ ÅÕÝ¥"" = 2",Cwctype
iswalpha(),The iswalpha() function in C++ checks if the given wide character is an alphabet or not.,"#include <cwctype>
#include <iostream>
#include <cwchar>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t str[] = L""\u221c!$131\u2288@"";
	bool flag = 0;
	for (int i=0; i<wcslen(str); i++)
	{
		if (iswalpha(str[i]))
		{
			flag = 1;
			break;
		}
	}
	if (flag)
		wcout << str << L"" contains alphabets"";
	else
		wcout << str << L"" doesn't contain alphabets"";
		
	return 0;
}",int iswalpha(wint_t ch);,ch: The wide character to check.,∜!$131⊈@ doesn't contain alphabets,Cwctype
iswalnum(),The iswalnum() function in C++ checks if the given wide character is an alphanumeric character or not.,"#include <cwctype>
#include <iostream>
#include <clocale>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t wc1 = L'\u00b6';
	wchar_t wc2 = L'\u00c5';
	wcout << L""In the current locale"" << endl;
	
	iswalnum(wc1)?wcout << wc1 << "" is alphanumeric "":wcout << wc1 << "" is not alphanumeric "";
	wcout << endl;
	iswalnum(wc2)?wcout << wc2 << "" is alphanumeric "":wcout << wc2 << "" is not alphanumeric "";
	
	return 0;
}",int iswalnum(wint_t ch);,ch: The wide character to check.,"In the current locale
¶ is not alphanumeric
Å is alphanumeric",Cwctype
getc(),The getc() function in C++ reads the next character from the given input stream. It can be implemented as macro.,"#include <cstdio>

int main()
{
    int c;
    FILE *fp;
    
    fp = fopen(""file.txt"",""r"");
    
    if (fp)
    {
        while(feof(fp) == 0)
        {
            c = getc(fp);
            putchar(c);
        }
    }
    else
        perror(""File opening failed"");
    fclose(fp);
    return 0;
}",int getc(FILE* stream);,"The getc() and fgetc() functions in C++ are almost similar. However there are some differences between them.The getc() function can be implemented as a macro whereas fgetc() function can not be used as macro.Also getc() function is highly optimized and hence calls to fgetc() probably take longer than calls to getc(). So, getc() is preferred in most situations.It is defined in <cstdio> header file.",Hello World!,Cstdio
fseek(),The fseek() function in C++ sets the file position indicator for the given file stream.,"#include <cstdio>

int main()
{
	FILE* fp = fopen(""example.txt"",""w+"");
	char ch;

	fputs(""Erica 25 Berlin"", fp);
	rewind(fp);

	printf(""Name: "");
	while((ch=fgetc(fp))!=' ')
		putchar(ch);
	putchar('\n');
	
	printf(""Age: "");
	fseek(fp,10,SEEK_SET);
	while((ch=fgetc(fp))!=' ')
		putchar(ch);
	putchar('\n');

	printf(""City: "");
	fseek(fp,15,SEEK_SET);
	while((ch=fgetc(fp))!=EOF)
		putchar(ch);
	putchar('\n');

	fclose(fp);
	return 0;
}","int fseek(FILE* stream, long offset, int origin);","stream: The file stream to modify.
offset: The number of characters to displace from the origin.
origin: Position used as reference to add to offset. It can have following values:fseek() origin values


Value
Description




SEEK_SET
Beginning of file


SEEK_CUR
Current position of file pointer


SEEK_END
End of file","Name: Erica
Age: 25
City: Berlin",Cstdio
ungetc(),The ungetc() function in C++ push the previously read character back to the stream so that it could be read again.,"#include <cstdio>
#include <cctype>
#include <iostream>
using namespace std;

int main()
{
	int c;
	long value = 0;
	char str[] = ""101axc"";

	FILE *fp = fopen(""file.txt"", ""r+"");
	fputs(str,fp);
	rewind(fp);

	while(1)
	{
		c = fgetc(fp);
		if (isdigit(c))
			value = value*10 + c - '0';
		else
			break;
	}

	ungetc(c, fp);
	cout << ""Value = "" << value << endl;
	fclose(fp);

	return 0;
}","int ungetc(int ch, FILE* stream);","ch: The character to be pushed back.
stream: File stream where the character is pushed back.",Value = 101,Cstdio
vsscanf(),The vsscanf() function in C++ is used to read the data from a string buffer.,%[*][width][length]specifier,"int vsscanf(const char* buffer, const char* format, va_list vlist );","format: Pointer to a null-terminated character string that specifies how to read the input. It consists of format specifiers starting with %.
		The format string has the following parts:
		
Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, vsscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that vsscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.




Format specifiers


Format Specifier
Description




%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[*][width][length]specifier

vlist: A list of arguments for receiving the inputs.",Bruce Wayne is Batman.,Cstdio
vscanf(),The vscanf() function in C++ is used to read the data from stdin.,%[*][width][length]specifier,"int vscanf( const char* format, va_list vlist );","format: Pointer to a null-terminated character string that specifies how to read the input. It consists of format specifiers starting with %.
		The format string has the following parts:
		
Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, vscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that vscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.




Format specifiers


Format Specifier
Description




%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[*][width][length]specifier

vlist: A list of arguments for receiving the inputs.","Enter subject's name and marks obtained: math 12
You scored 12.00 in math",Cstdio
vfscanf(),The vfscanf() function in C++ is used to read the data from a file stream.,%[*][width][length]specifier,"int vfscanf(FILE* stream, const char* format, va_list vlist );","stream: Input file stream to read the data from.
format: Pointer to a null-terminated character string that specifies how to read the input. It consists of format specifiers starting with %.
vlist: Variable argument list where the values are to be stored
		The format string has the following parts:
		
Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, vfscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that vfscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.




Format specifiers


Format Specifier
Description




%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[*][width][length]specifier

vlist: A list of arguments for receiving the inputs.","Here are the list of my friends
Robert
Syd
Brian
Eddie
Ray",Cstdio
freopen(),The freopen() function in C++ tries to open a new file with a file stream that is associated with another opened file.,"#include <cstdio>
#include <cstdlib>

int main()
{
	FILE* fp = fopen(""test1.txt"",""w"");
	fprintf(fp,""%s"",""This is written to test1.txt"");

	if (freopen(""test2.txt"",""w"",fp))
		fprintf(fp,""%s"",""This is written to test2.txt"");
	else
	{
		printf(""freopen failed"");
		exit(1);
	}

	fclose(fp);
	return 0;
}","FILE* freopen( const char* filename, const char* mode, FILE* stream );","filename: New file to open.
mode: Mode to open the file with. Different types of file access mode are as follows:Different modes of file operation


File Access Mode
Interpretation
If file exists
If file doesn't exist




""r""
Opens the file in read mode
Read from start
Error


""w""
Opens the file in write mode
Erase all the contents
Create new file


""a""
Opens the file in append mode
Start writing from the end
Create new file


""r+""
Opens the file in read and write mode
Read from start
Error


""w+""
Opens the file in read and write mode
Erase all the contents
Create new file


""a+""
Opens the file in read and write mode
Start writing from the end
Create new filestream: The file stream to associate filename to.","The following will be written to test1.txt:
This is written to test1.txt
The following will be written to test2.txt:
This is written to test2.txt",Cstdio
fflush(),The fflush() function in C++ flushes any buffered data to the respective device.,"#include <cstdio>
#include <cstring>

int main()
{
	int x;
	char buffer[1024];

	setvbuf(stdout, buffer, _IOFBF, 1024);
	printf(""Enter an integer - "");

	fflush(stdout);

	scanf(""%d"",&x);
	printf(""You entered %d"", x);

	return(0);
}",int fflush(FILE* stream);,stream: The stream to be flushed.,"Enter an integer - 2
You entered 2",Cstdio
setvbuf(),The setvbuf() function in C++ is used to change or specify the buffering mode and size of the buffer.,"#include <iostream>
#include <cstdio>

#define SIZE 1024

using namespace std;

int main()
{
    char buffer[SIZE] = ""..."";
    char str[] = ""This is first line\nThis is second line"";
    FILE *fp = fopen(""test.txt"",""wb+"");

    /* no buffering, buffer remains unchanged */
    setvbuf(fp,buffer,_IONBF,SIZE);
    fwrite(str, sizeof(str), 1, fp);
    cout << buffer << endl;

    /* line buffering, only a single line is buffered */
    setvbuf(fp,buffer,_IOLBF,SIZE);
    fwrite(str, sizeof(str), 1, fp);
    cout << buffer << endl;

    /* full buffering, all the contents are buffered */
    setvbuf(fp,buffer,_IOFBF,SIZE);
    fwrite(str, sizeof(str), 1, fp);
    cout << buffer << endl;

    fclose(fp);
    return 0;
}","int setvbuf(FILE* stream, char* buffer, int mode, size_t size);","stream: A file stream.
buffer: Pointer to the buffer to be used by stream.
mode: Buffering mode. The types of buffering modes are:
		
_IOFBF: full buffering
_IOLBF: line buffering
_IONBF: no buffering


size: The size of buffer in bytes.","...
This is second line
This is first line
This is second line",Cstdio
perror(),The perror() function in C++ prints the error message to stderr based on the error code currently stored in the system variable errno.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    char filename[] = ""example.txt"";
    
/* if the file can not be reomved */    
if (remove(filename) != 0)
        perror(""File deletion failed"");
    else
        cout << ""File deleted successfully"";
    
    return 0;
}",void perror(const char* str);,str: Pointer to a null terminated string.,File deletion failed: No such file or directory,Cstdio
ferror(),The ferror() function in C++ checks for error in the given stream.,"#include <iostream>
#include <cstdio>

using namespace std;

int main ()
{
    int ch;
    FILE* fp;
    fp = fopen(""file.txt"",""w"");
    
    if(fp)
    {
        ch = getc(fp);
        if (ferror(fp))
            cout << ""Can't read from file"";
    }
    fclose (fp);
    return 0;
}",int ferror(FILE* stream);,stream: The file stream who error is to be checked.,Can't read from file,Cstdio
feof() function,The feof() function in C++ checks if the end of the file associated with the given file stream has been reached or not.,"#include <cstdio>

using namespace std;

int main()
{
    int c;
    FILE *fp;
    fp = fopen(""file.txt"", ""r"");
    if (fp)
    {
        while(!feof(fp))
        {
            c = getc(fp);
            putchar(c);
        }
    }
    fclose(fp);
    return 0;
}",int feof(FILE* stream);,stream: The file stream who end is to be checked.,Welcome to Programiz.com,Cstdio
clearerr(),The clearerr() function in C++ resets the error flags and the EOF indicator for the given file stream.,"#include <iostream>
#include <cstdio>

using namespace std;

int main ()
{
    int ch;
    FILE* fp;
    fp = fopen(""file.txt"",""w"");
    
    if(fp)
    {
        ch = getc(fp);
        if(ferror(fp))
        {
            cout << ""Error set"" << endl;
            clearerr (fp);
        }
    }
    if(!ferror(fp))
        cout << ""Error reset"";
    fclose (fp);
    return 0;
}",void clearerr(FILE* stream);,stream: The file stream to reset the error flags and EOF indicator.,"Error set
Error reset",Cstdio
rewind(),The rewind() function in C++ sets the file position indicator to the beginning of the given file stream.,"#include <cstdio>

int main()
{
    int c;
    FILE *fp;
    fp = fopen(""file.txt"", ""r"");
    if (fp)
    {
        while ((c = getc(fp)) != EOF)
            putchar(c);
        
        rewind(fp);
        putchar('\n');
        
        while ((c = getc(fp)) != EOF)
            putchar(c);
    }
    fclose(fp);
    return 0;
}",void rewind(FILE* stream);,stream: The file stream to reset the error flags and EOF indicator.,"Welcome to Programiz.com
Welcome to Programiz.com",Cstdio
ftell(),The ftell() function in C++ returns the current position of the file pointer.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    int pos;
    char c;
    FILE *fp;
    fp = fopen(""file.txt"", ""r"");
    if (fp)
    {
        while ((c = getc(fp)) != EOF)
        {
            pos = ftell(fp);
            cout << ""At position "" << pos << "", character is "" << c << endl;
        }
    }
    else
    {
        perror(""Error reading file"");
    }
    fclose(fp);
    return 0;
}",long ftell(FILE* stream);,stream: The file stream whose current position is returned.,"At position 1, character is P
At position 2, character is r
At position 3, character is o
At position 4, character is g
At position 5, character is r
At position 6, character is a
At position 7, character is m
At position 8, character is i
At position 9, character is z
At position 10, character is .
At position 11, character is c
At position 12, character is o
At position 13, character is m",Cstdio
fsetpos(),The fsetpos() function in C++ sets the file pointer associated with stream to a given position.,"#include <cstdio>

int main()
{
    FILE *fp;
    fpos_t pos;
    int c;
    
    fp = fopen(""myfile.txt"",""w+"");
    
    fputs(""What a boring day!\n"",fp);
    fgetpos(fp, &pos);
    fputs(""The weather is bad"",fp);
    
    fsetpos(fp, &pos);
    /*  Replaces the second line by new string  */
    fputs(""It is raining badly."",fp);
    rewind(fp);
    
    while(!feof(fp))
    {
        c = getc(fp);
        putchar(c);
    }
    
    fclose(fp);
    return 0;
}","int fsetpos(FILE* stream, const fpos_t* pos);","stream: The file stream whose position is to be set.
pos: Position value obtained from a previous call to fgetpos that indicates the position of the file pointer at that moment.","What a boring day!
It is raining badly.",Cstdio
fgetpos(),The fgetpos() function in C++ gets the current file position indicator.,"#include <cstdio>

int main()
{
    FILE *fp;
    fpos_t pos;
    int c;
    
    fp = fopen(""myfile.txt"",""w+"");
    
    /*  Get the beginning position  */
    fgetpos(fp, &pos);
    fputs(""What a great day!"",fp);
    
    /*  Set the position to the start  */
    fsetpos(fp, &pos);
    
    while(!feof(fp))
    {
        c = getc(fp);
        putchar(c); 
    }
    
    fclose(fp);
    return 0;
}","int fgetpos(FILE* stream, fpos_t* pos);","stream: The file stream whose file position indicator is returned.
pos: A pointer to fpos_t object to store the file position indicator.",What a great day!,Cstdio
fwrite(),The fwrite() function in C++ writes a specified number of characters to the given output stream.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    int retVal;
    FILE *fp;
    char buffer[] = ""Writing to a file using fwrite."";

    fp = fopen(""data.txt"",""w"");
    retVal = fwrite(buffer,sizeof(buffer),1,fp);
    
    cout << ""fwrite returned "" << retVal;
    return 0;
}","size_t fwrite(const void * buffer, size_t size, size_t count, FILE * stream);","buffer: Pointer to the block of memory whose content is written.
size: Size of each objects in bytes.
count: The number of objects to read.
stream: The file stream to write the data to.",fwrite returned 1,Cstdio
fread(),The fread() function in C++ reads a specified number of characters from the given input stream.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    FILE *fp;
    char buffer[100];
    
    fp = fopen(""data.txt"",""rb"");
    while(!feof(fp))
    {
        fread(buffer,sizeof(buffer),1,fp);
        cout << buffer;
    }
    
    return 0;
}","size_t fread(void * buffer, size_t size, size_t count, FILE * stream);","buffer: Pointer to the block of memory to store the objects.
size: Size of each objects in bytes.
count: The number of objects to read.
stream: The file stream to read the data from.","Dennis Ritchie : C
Bjarne Stroustrup : C++
Guido van Rossum : Python
James Gosling : Java",Cstdio
putchar(),The putchar() function in C++ writes a character to stdout.,"#include <cstdio<

int main()
{   
    for (int i=48; i<58; i++)
    {
        /*  Writes the equivalent character */
        putchar(i);
        putchar(' ');
    }
    
    return 0;
}",int putchar(int ch);,ch: The character to be written.,0 1 2 3 4 5 6 7 8 9,Cstdio
putc(),The putc() function in C++ writes a character to the given output stream.,"#include <cstdio>
#include <cstring>

int main()
{
    char str[] = ""Testing putc() function"";
    FILE *fp;
    
    fp = fopen(""file.txt"",""w"");
    
    if (fp)
    {
        for(int i=0; i<strlen(str); i++)
        {
            putc(str[i],fp);
        }
    }
    else
        perror(""File opening failed"");
    
    fclose(fp);
    return 0;
}","int putc(int ch, FILE* stream);","ch: The character to be written.
stream: The file stream to write the character.",,Cstdio
gets(),The gets() function in C++ reads characters from stdin and stores them until a newline character is found or end of file occurs.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    char str[100];
    cout << ""Enter a string: "";
    gets(str);
    cout << ""You entered: "" << str;
    
    return 0;
}",char* gets(char* str);,str: Pointer to an character array that stores the characters from stdin.,"Enter a string: Have a great day!
You entered: Have a great day!",Cstdio
getchar(),The getchar() function in C++ reads the next character from stdin.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    int c,i=0;
    char str[100];
    
    cout << ""Enter characters, Press Enter to stop\n"";
    
    do
    {
        c = getchar();
        str[i] = c;
        i++;
    } while(c!='\n');
    
    cout << str;
    return 0;
}",int getchar();,None.,"Enter characters, Press Enter to stop
rtq paSd12 6.2 haQ
rtq paSd12 6.2 haQ",Cstdio
fputc(),The fputc() function in C++ writes a character to the given output stream.,"#include <cstdio>
#include <cstring>

int main()
{
    char str[] = ""Hello programmers"";
    FILE *fp;
    
    fp = fopen(""file.txt"",""w"");
    
    if (fp)
    {
        for(int i=0; i<strlen(str); i++)
        {
            fputc(str[i],fp);
        }
    }
    else
        perror(""File opening failed"");
    
    fclose(fp);
    return 0;
}","int fputc(int ch, FILE* stream);","ch: The character to be written.
stream: The file stream to write the character.",,Cstdio
fgets(),The fgets() function in C++ reads a specified maximum number of characters from the given file stream.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    int count = 10;
    char str[10];
    FILE *fp;
    
    fp = fopen(""file.txt"",""w+"");
    fputs(""An example file\n"", fp);
    fputs(""Filename is file.txt\n"", fp);
    
    rewind(fp);
    
    while(feof(fp) == 0)
    {
        fgets(str,count,fp);
        cout << str << endl;
    }
    
    
    fclose(fp);
    return 0;
}","char* fgets(char* str,int count,FILE* stream);","str: Pointer to an character array that stores the content of file.
count: Maximum number of characters to write.
stream: The file stream to read the characters.","An exampl
e file

Filename
is file.t
xt",Cstdio
vsprintf(),The vsprintf() function in C++ is used to write a formatted string to a string buffer.,"#include <cstdio>
#include <cstdarg>

void write(char* buf, const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vsprintf(buf, fmt, args);
    va_end(args);
}

int main ()
{
    char buffer[100];
    char fname[20] = ""Bjarne"";
    char lname[20] = ""Stroustrup"";
    char lang[5] = ""C++"";

    write(buffer, ""%s was created by %s %s\n"", lang, fname, lname);

    printf(""%s"", buffer);

    return 0;
}","int vsprintf( char* buffer, const char* format, va_list vlist );","buffer: Pointer to a character string to write the result.
format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.
		The format specifiers are replaced by the values of respective variables that follows the format string.
The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.











So the general format of format specifier is: %[flags][width][.precision][length]specifier



vlist: A list of arguments containing the data to write.",C++ was created by Bjarne Stroustrup,Cstdio
vsnprintf(),The vsnprintf() function in C++ is used to write a formatted string to a string buffer.,"#include <cstdio>
#include <cstdarg>

void write(char* buf, int buf_size, const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, buf_size, fmt, args);
    va_end(args);
}

int main ()
{
    char buffer[100];
    char fname[20] = ""Bjarne"";
    char lname[20] = ""Stroustrup"";
    char lang[5] = ""C++"";

    write(buffer, 27, ""%s was created by %s %s\n"", lang, fname, lname);

    printf(""%s"", buffer);

    return 0;
}","int vsnprintf( char* buffer, size_t buf_size, const char* format, va_list vlist );","buffer: Pointer to a character string to write the result.
buf_size: Maximum number of characters to write.
format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.
		







The format specifiers are replaced by the values of respective variables that follows the format string.
The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.



So the general format of format specifier is: %[flags][width][.precision][length]specifier



vlist: A list of arguments containing the data to write.",C++ was created by Bjarne,Cstdio
vprintf(),The vprintf() function in C++ is used to write a formatted string to stdout.,"#include <cstdio>
#include <cstdarg>

void write(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

int main ()
{
    char name[50] = ""Jim"";
    char address[50] = ""Cardiff"";
    int age = 13;
    
    write(""My name is %s. I am %d years old and I live in %s.\n"", name, age, address);

    return 0;
}","int vprintf( const char* format, va_list vlist );","format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.

		The format specifiers are replaced by the values of respective variables that follows the format string.
The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.











So the general format of format specifier is: %[flags][width][.precision][length]specifier



vlist: A list of arguments containing the data to print.",My name is Jim. I am 13 years old and I live in Cardiff.,Cstdio
vfprintf(),The vfprintf() function in C++ is used to write a formatted string to a file stream.,"#include <cstdio>
#include <cstdarg>

void write(FILE* fp, const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vfprintf(fp, fmt, args);
    va_end(args);
}

int main ()
{
    FILE *fp = fopen(""data.csv"",""w"");
    char name[5][50] = {""John"",""Harry"",""Kim"",""Yuan"",""Laxmi""};
    int age[5] = {13,41,26,21,32};

    write(fp, ""%s,%s\n"", ""name"", ""age"");
    for (int i=0; i<5; i++)
        write(fp, ""%s,%d\n"", name[i], age[i]);

    return 0;
}","int vfprintf( FILE* stream, const char* format, va_list vlist );","stream: An output file stream to write the result.
format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.
		The format specifiers are replaced by the values of respective variables that follows the format string.
The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.











So the general format of format specifier is: %[flags][width][.precision][length]specifier



vlist: A list of arguments containing the data to write.","name,age
John,13
Harry,41
Kim,26
Yuan,21
Laxmi,32",Cstdio
sscanf(),The sscanf() function in C++ is used to read the data from string buffer.,"#include <cstdio>

int main ()
{
    char fname[50], lname[50];
    char buffer[] = ""Dennis Ritchie"";

    sscanf(buffer, ""%s %s"", fname, lname);
    printf(""First name : %s \nLast name : %s\n"", fname, lname);

    return 0;
}","int sscanf( const char* buffer, const char* format, ... );","buffer: Pointer to a null-terminated character string to read the data from.
format: Pointer to a null-terminated character string that specifies how to read the input. It consists of format specifiers starting with %.
		







The format string has the following parts:

Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, fscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that fscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.
						


Format Specifier
Description





%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.







		So the general format of format specifier is: %[*][width][length]specifier
… : Other additional arguments for receiving data. They occur in a sequence according to the format specifier.","First name : Dennis 
Last name : Ritchie",Cstdio
sprintf(),The sprintf() function in C++ is used to write a formatted string to character string buffer.,"#include <cstdio>
#include <iostream>

using namespace std;

int main()
{
    char buffer[100];
    int retVal;
    char name[] = ""Max"";
    int age = 23;

    retVal = sprintf(buffer, ""Hi, I am %s and I am %d years old"", name, age);
    cout << buffer << endl;
    cout << ""Number of characters written = "" << retVal << endl;

    return 0;
}","int sprintf( char* buffer, const char* format, ... );","buffer: Pointer to the string buffer to write the result.
format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.
		The format specifiers are replaced by the values of respective variables that follows the format string.








The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.



So the general format of format specifier is: %[flags][width][.precision][length]specifier



… : Other additional arguments specifying the data to be printed. They occur in a sequence according to the format specifier.","Hi, I am Max and I am 23 years old
Number of characters written = 34",Cstdio
snprintf(),The snprintf() function in C++ is used to write a formatted string to character string buffer.,"#include <cstdio>
#include <iostream>

using namespace std;

int main()
{
    char buffer[100];
    int retVal, buf_size = 100;
    char name[] = ""Max"";
    int age = 23;

    retVal = snprintf(buffer, buf_size, ""Hi, I am %s and I am %d years old"", name, age);
    if (retVal > 0 && retVal < buf_size)
    {
        cout << buffer << endl;
        cout << ""Number of characters written = "" << retVal << endl;
    }
    else
        cout << ""Error writing to buffer"" << endl;

    return 0;
}","int snprintf( char* buffer, size_t buf_size, const char* format, ... );","buffer: Pointer to the string buffer to write the result.
buf_size: Specify maximum number of characters to be written to buffer which is buf_size-1.
format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.
		The format specifiers are replaced by the values of respective variables that follows the format string.








The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.



So the general format of format specifier is: %[flags][width][.precision][length]specifier



… : Other additional arguments specifying the data to be printed. They occur in a sequence according to the format specifier.","Hi, I am Max and I am 23 years old
Number of characters written = 34",Cstdio
scanf,The scanf() function in C++ is used to read the data from stdin.,"#include <cstdio>

int main ()
{
    FILE *fp;
    char name[50];
    int age;
    
    fp = fopen(""example.txt"",""w"");
    fprintf(fp, ""%s %d"", ""Tim"", 31);
    fclose(fp);

    fp = fopen(""example.txt"",""r"");
    scanf(fp, ""%s %d"", name, &age);
    fclose(fp);

    printf(""Hello %s, You are %d years old\n"", name, age);
    return 0;
}","int scanf( const char* format, ... );","format: Pointer to a null-terminated character string that specifies how to read the input. It consists of format specifiers starting with %.

		







The format string has the following parts:

Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, scanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that scanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.
						


Format Specifier
Description





%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.







		So the general format of format specifier is: %[*][width][length]specifier
… : Other additional arguments for receiving data. They occur in a sequence according to the format specifier.","Hello Tim, You are 31 years old",Cstdio
printf(),The printf() function in C++ is used to write a formatted string to stdout.,"#include <cstdio>

int main()
{
    int x = 5;
    char my_name[] = ""Lincoln"";

    printf(""x = %d \n"", x);
    printf(""My name is %s \n"", my_name);
    
    return 0;
}","int printf( const char* format, ... );","format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.

		The format specifiers are replaced by the values of respective variables that follows the format string.
The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.











So the general format of format specifier is: %[flags][width][.precision][length]specifier



… : Other additional arguments specifying the data to be printed. They occur in a sequence according to the format specifier.","x = 5 
My name is Lincoln",Cstdio
fscanf(),The fscanf() function in C++ is used to read the data from file stream.,"#include <cstdio>

int main ()
{
    FILE *fp;
    char name[50];
    int age;
    
    fp = fopen(""example.txt"",""w"");
    fprintf(fp, ""%s %d"", ""Tim"", 31);
    fclose(fp);

    fp = fopen(""example.txt"",""r"");
    fscanf(fp, ""%s %d"", name, &age);
    fclose(fp);

    printf(""Hello %s, You are %d years old\n"", name, age);
    return 0;
}","int fscanf( FILE* stream, const char* format, ... );","stream: An input file stream to read the data from.
format: Pointer to a null-terminated character string that specifies how to read the input. It consists of format specifiers starting with %.
		







The format string has the following parts:

Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, fscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that fscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.
						


Format Specifier
Description





%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.







		So the general format of format specifier is: %[*][width][length]specifier
… : Other additional arguments for receiving data. They occur in a sequence according to the format specifier.","Hello Tim, You are 31 years old",Cstdio
fprintf(),The fprintf() function in C++ is used to write a formatted string to file stream.,"#include <cstdio>

int main()
{
    FILE *fp;
    fp = fopen(""example.txt"",""w"");
    char lang[5][20] = {""C"",""C++"",""Java"",""Python"",""PHP""};

    fprintf(fp,""Top 5 programming language\n"");
    for (int i=0; i<5; i++)
        fprintf(fp, ""%d. %s\n"", i+1, lang[i]);

    fclose(fp);
    return 0;
}","int fprintf(FILE* stream, const char* format, ...);","stream: Pointer to an output file stream where the contents are written.
format: Pointer to a null terminated string that is written to the file stream. It consists of characters along with optional format specifiers starting with %.
		The format specifiers are replaced by the values of respective variables that follows the format string.
The format specifier has the following parts:

A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:
				


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.











So the general format of format specifier is: %[flags][width][.precision][length]specifier



… : Other additional arguments specifying the data to be printed. They occur in a sequence according to the format specifier.","Top 5 programming language
1. C
2. C++
3. Java
4. Python
5. PHP",Cstdio
setbuf(),The setbuf() function in C++ sets the internal buffer to be used for I/O operations by a stream.,"#include <iostream>
#include <cstdio>

using namespace std;

int main ()
{
    char str[] = ""Buffered Stream"";
    char buffer[BUFSIZ];
    
    FILE *fp;
    fp=fopen (""test.txt"",""wb"");
    
    setbuf(fp,buffer);
    fwrite(str, sizeof(str), 1, fp);
    
    fflush(fp);
    fclose(fp);

    cout << buffer;
    
    return 0;
}","void setbuf(FILE* stream, char* buffer);","stream: A file stream.
buffer: A pointer to a buffer which may be null or not. If it is null, buffering is turned off, otherwise it should of at least BUFSIZ bytes.",Buffered Stream,Cstdio
fopen(),The fopen() function in C++ opens a specified file in a certain mode.,"#include <cstdio>
#include <cstring>

using namespace std;

int main()
{
	int c;
	FILE *fp;
	fp = fopen(""file.txt"", ""w"");
	char str[20] = ""Hello World!"";
	if (fp)
	{
		for(int i=0; i<strlen(str); i++) 
			putc(str[i],fp);
	}
	fclose(fp);
}","FILE* fopen (const char* filename, const char* mode);","filename: Pointer to the string containing the name of the file to be opened.
mode: Pointer to the string that specifies the mode in which file is opened.",Hello World!,Cstdio
fclose(),The fclose() function in C++ closes the given file stream.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
	FILE *fp;
	fp = fopen(""file.txt"",""w"");
	char str[20] = ""Hello World!"";
	
	if (fp == NULL)
	{
		cout << ""Error opening file"";
		exit(1);
	}
	fprintf(fp,""%s"",str);
	fclose(fp);
	cout << ""File closed successfully"";
	return 0;
}",int fclose(FILE* stream);,stream: The file stream to close.,File closed successfully,Cstdio
tmpnam(),The tmpnam() function in C++ generates a unique filename that can be used to create a temporary file without overwriting any existing one.,"#include <iostream>
#include <cstdio>

using namespace std;

int main ()
{
	char filename1[L_tmpnam],filename2[L_tmpnam];
	
	tmpnam(filename1);
	tmpnam(filename2);
	cout << ""Temporary filenames:"" << endl;
	cout << ""1. "" << filename1 << endl;
	cout << ""2. "" << filename2 << endl;

	/*	when null is passed	*/
	char* filename3 = tmpnam(NULL);
	cout << ""3. "" << filename3; 

  return 0;  
}",char* tmpnam(char* filename);,"filename: Pointer to an character array of L_tmpnam bytes, where the proposed temporary name will be stored. If the parameter is a null pointer, the string will be stored in an internal static array.","Temporary filenames:
1. \s1dg.
2. \s1dg.1
3. \s1dg.2",Cstdio
tmpfile(),The tmpfile() function in C++ creates and opens a temporary file in binary read/write (wb+) mode with a unique auto-generated filename.,"#include <iostream>
#include <cstdio>
#include <cstdlib>

using namespace std;

int main()
{
	FILE *fp;
	fp = tmpfile();
	char writeToFile[50] = ""Creating a temporary file"";
	
	if (fp==NULL)
	{
		perror(""Error creating temporary file"");
		exit(1);
	}
	
	fputs(writeToFile,fp);
	rewind(fp);
	
	char readFromFile[50];
	fgets(readFromFile, sizeof(readFromFile), fp);
	cout << readFromFile;
	fclose(fp);
	
	return 0;
}",FILE* tmpfile();,None,Creating a temporary file,Cstdio
rename(),The rename() function in C++ renames a specified file.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
	char oldname[] = ""file_old.txt"";
	char newname[] = ""file_new.txt"";
	
	/*	Deletes the file if exists */
	if (rename(oldname, newname) != 0)
		perror(""Error renaming file"");
	else
		cout << ""File renamed successfully"";
	
	return 0;
}","int rename( const char *oldname, const char *newname );","oldname: Pointer to the string containing the old name of the file along with the path to rename.
newname: Pointer to the string containing the new name of the file along with the path.",File renamed successfully,Cstdio
remove(),The remove() function in C++ deletes a specified file.,"#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
	char filename[] = ""C:\\Users\\file.txt"";
	
	/*	Deletes the file if exists */
	if (remove(filename) != 0)
		perror(""File deletion failed"");
	else
		cout << ""File deleted successfully"";
	
	return 0;
}",int remove(const char* filename);,filename: Pointer to the string containing the name of the file along with the path to delete.,"If the file is deleted successfully:
File deleted successfully
If the file is not present:
File deletion failed: No such file or directory",Cstdio
wcscoll(),The wcscoll() function in C++ compares two null terminated string. The comparison is based on the current locale defined by the LC_COLLATE category.,"#include <iostream>
#include <clocale>
#include <cwchar>
using namespace std;

void compare(const wchar_t* p1, const wchar_t* p2)
{
	if(wcscoll(p1, p2) < 0)
		wcout << p1 << L"" precedes "" << p2 << '\n';
	else if (std::wcscoll(p1, p2) > 0)
		wcout << p2 << L"" precedes "" << p1 << '\n';
	else
		wcout << p2 << L"" equals "" << p1 << '\n';
}

int main()
{
	wchar_t str1[] = L""årtist"";
	wchar_t str2[] = L""äpple"";
	
	setlocale(LC_ALL, ""en_US.utf8"");
	wcout << L""In the American locale: "";
	compare(str1, str2);

	setlocale(LC_ALL, ""sv_SE.utf8"");
	wcout << L""In the Swedish locale: "";
	compare(str1, str2);
	
	return 0;
}","int wcscoll( const wchar_t* lhs, const wchar_t* rhs );",lhs and rhs: Pointer to the null terminated wide strings to compare.,"In the American locale: äpple precedes årtist
In the Swedish locale: årtist precedes äpple",Cwchar
wcstoull(),The wcstoull() function in C++ interprets the contents of a wide string as an unsigned integral number of the specified base and returns its value as a unsigned long long int.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t str1[] = L""101aa\u16b6"";
	wchar_t str2[] = L""59"";
	wchar_t *end;
	unsigned long long value;
	int base = 10;
	
	value = wcstoull(str1, &end, base);
	wcout << L""String value = "" << str1 << endl;
	wcout << L""Unsigned Long Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	value = wcstoull(str2, &end, base);
	wcout << L""String value = "" << str2 << endl;
	wcout << L""Unsigned Long Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	return 0;
}","unsigned long wcstoull( const wchar_t* str, wchar_t** str_end, int base );","str: A wide string having the representation of an unsigned integral number.
str_end: A pointer to a pointer to a wide character. The value of str_end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.
base: The base of the integral value. The set of valid values for base is {0, 2, 3, …, 35, 36}.","String value = 101aaᚶ
Unsigned Long Long Int value = 101
End String = aaᚶ
String value = 59
Unsigned Long Long Int value = 59
End String =",Cwchar
wcstoul(),The wcstoul() function in C++ interprets the contents of a wide string as an unsigned integral number of the specified base and returns its value as a unsigned long int.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t str1[] = L""101aa\u16b6"";
	wchar_t str2[] = L""59"";
	wchar_t *end;
	unsigned long value;
	int base = 10;
	
	value = wcstoul(str1, &end, base);
	wcout << L""String value = "" << str1 << endl;
	wcout << L""Unsigned Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	value = wcstoul(str2, &end, base);
	wcout << L""String value = "" << str2 << endl;
	wcout << L""Unsigned Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	return 0;
}","unsigned long wcstoul( const wchar_t* str, wchar_t** str_end, int base );","str: A wide string having the representation of an unsigned integral number.
str_end: A pointer to a pointer to a wide character. The value of str_end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.
base: The base of the integral value. The set of valid values for base is {0, 2, 3, …, 35, 36}.","String value = 101aaᚶ
Unsigned Long Int value = 101
End String = aaᚶ
String value = 59
Unsigned Long Int value = 59
End String =",Cwchar
wcstoll(),The wcstoll() function in C++ interprets the contents of a wide string as an integral number of the specified base and returns its value as a long long int.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t str1[] = L""41\u0166\u0124xx"";
	wchar_t str2[] = L""127"";
	wchar_t *end;
	long long value;
	int base = 10;
	
	value = wcstoll(str1, &end, base);
	wcout << L""String value = "" << str1 << endl;
	wcout << L""Long Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	value = wcstoll(str2, &end, base);
	wcout << L""String value = "" << str2 << endl;
	wcout << L""Long Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	return 0;
}","long long wcstoll( const wchar_t* str, wchar_t** str_end, int base );","str: A wide string having the representation of an integral number.
str_end: A pointer to a pointer to a wide character. The value of str_end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.
base: The base of the integral value. The set of valid values for base is {0, 2, 3, …, 35, 36}.","String value = 41ŦĤxx
Long Long Int value = 41
End String = ŦĤxx
String value = 127
Long Long Int value = 127
End String =",Cwchar
wcsftime(),The wcsftime() function in C++ converts the given date and time from a given calendar time time to a null-terminated wide character string according to a format string.,"#include <ctime>
#include <cwchar>
#include <iostream>
using namespace std;

int main()
{
	time_t curr_time;
	tm * curr_tm;
	wchar_t date_string[100];
	wchar_t time_string[100];
	
	time(&curr_time);
	curr_tm = localtime(&curr_time);
	
	wcsftime(date_string, 50, L""Today is %B %d, %Y"", curr_tm);
	wcsftime(time_string, 50, L""Current time is %T"", curr_tm);
	
	wcout << date_string << endl;
	wcout << time_string << endl;
	
	return 0;
}","size_t wcsftime( wchar_t* str, size_t count, const wchar_t* format, const tm* time );","str: Pointer to the first element of the wide character array to store the result.
count: Maximum number of wide character to write.
format: Pointer to a null-terminated wide character string specifying the format of conversion. The format string consists of conversion specifier (beginning with % and optionally followed by E or O) and other ordinary wide characters.
		The ordinary wide characters including the terminating null wide character are copied as it is to the output wide string.
		
Format specifiers for wcsftime()


Conversion Specifier
Description
Used Fields




%
Writes the character %


n
Writes newline character


t
Writes horizontal tab character


Year


Y
Writes 4 digits of year, e.g. 2011
tm_year


EY
Writes 4 digits of year in locale's alternative representation
tm_year


y
Writes last 2 digits of year, range [00, 99]
tm_year


Oy
Writes the last 2 digits of year in locale's alternative representation
tm_year


Ey
Writes year as offset from locale's alternative calendar period %EC (locale-dependent)
tm_year


C
Writes first 2 digits of year, range [00,99]
tm_year


EC
Writes name of the base year (period) in the locale's alternative representation,
tm_year


G
Writes ISO 8601 week-based year, i.e. the year that contains the specified week.
tm_year, tm_wday, tm_yday


g
Writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]).
tm_year, tm_wday, tm_yday


Month


b
Writes abbreviated month name, e.g. Jan
tm_mon


h
Same as b
tm_mon


B
Writes full month name, e.g. January
tm_mon


m
Writes month as a decimal number, range [01,12]
tm_mon


Om
Writes month using the locale's alternative numeric system
tm_mon


Week


U
Writes week of the year as a decimal number from 00 to 53 (Sunday is the first day of the week)
tm_year, tm_wday, tm_yday


OU
Writes week of the year as by %U using the alternative numeric system
tm_year, tm_wday, tm_yday


W
Writes week of the year as a decimal number from 00 to 53 (Monday is the first day of the week)
tm_year, tm_wday, tm_yday


OW
Writes week of the year as by %W using the alternative numeric system
tm_year, tm_wday, tm_yday


V
Writes ISO 8601 week of the year (range [01,53]).
tm_year, tm_wday, tm_yday


OV
Writes week of the year, as by %V, using the alternative numeric system
tm_year, tm_wday, tm_yday


Day of the year/month


j
Writes day of the year as a decimal number, range [001,366]
tm_yday


d
Writes day of the month as a decimal number, range[01,31]
tm_mday


Od
Writes day of the month, as by %d, using the alternative numeric system
tm_mday


e
Writes day of the month as a decimal number, range[1,31]
tm_mday


Oe
Writes day of the month, as by %e, using the alternative numeric system
tm_mday


Day of the week


a
Writes abbreviated weekday name, e.g. Fri (locale dependent)
tm_wday


A
Writes full weekday name, e.g. Friday (locale dependent)
tm_wday


w
Writes weekday as a decimal number, range [0-6] (Sunday is 0)
tm_wday


Ow
Writes weekday as by %w, using the alternative numeric system
tm_wday


u
Writes weekday as a decimal number, where Monday is 1 (ISO 8601 format), range [1-7]
tm_wday


Ou
Writes weekday as by %u, using the alternative numeric system
tm_wday


Hour, minute, second


H
Writes hour as a decimal number, range [00,23]
tm_hour


OH
Writes hour as by %H, using the alternative numeric system
tm_hour


I
Writes hour as a decimal number, range[01,12]
tm_hour


OI
Writes hour as by %I, using the alternative numeric system
tm_hour


M
Writes minute as a decimal number, range [00,59]
tm_min


OM
Writes minute as by %M, using the alternative numeric system
tm_min


S
Writes second as a decimal number, range [00,60]
tm_sec


OS
Writes second as by %S, using the alternative numeric system
tm_sec


Other


c
Writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)
all


Ec
Writes locale's alternative date and time string
all


x
Writes localized date representation (locale dependent)
all


Ex
Writes locale's alternative date representation
all


X
Writes localized time representation (locale dependent)
all


EX
Writes locale's alternative time representation
all


D
Equivalent to ""%m/%d/%y""
tm_mon, tm_mday, tm_year


F
Equivalent to ""%Y-%m-%d""
tm_mon, tm_mday, tm_year


r
Writes localized 12-hour clock time
tm_hour, tm_min, tm_sec


R
Equivalent to ""%H:%M""
tm_hour, tm_min


T
Equivalent to ""%H:%M:%S
tm_hour, tm_min, tm_sec


P
Writes localized a.m. or p.m. (locale dependent)
tm_hour


z
writes offset from UTC in the ISO 8601 format (e.g. -0545), or no characters if the time zone information is not available
tm_isdst


Z
Writes time zone name or abbreviation, or nothing if the time zone information is not available (locale dependent)
tm_isdst




time: The date and time information to convert.","Today is April 21, 2017
Current time is 14:42:45",Cwchar
wmemset(),The wmemset() function in C++ copies a single wide character for a specified number of time to a wide character array.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t ch = L'\u2206';
	wchar_t dest[20];
	int count = 10;
	
	wmemset(dest, ch, count);
	wcout << L""After copying "" << ch << L"" 10 times"" << endl;
	
	for(int i=0; i<count; i++)
		putwchar(dest[i]);
	
	return 0;
}","wchar_t* wmemset( wchar_t* dest, wchar_t ch, size_t count );","dest: Pointer to the wide character array to copy the wide character.
ch: The wide character to copy.
count: Number of times to copy.","After copying ∆ 10 times
∆∆∆∆∆∆∆∆∆∆",Cwchar
wmemmove(),The wmemmove() function in C++ copies a specified number of wide characters from source to the destination.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t src[] = L""\u03b1\u03b2\u03b3\u03b8\u03bb\u03c9\u03c0"";
	wchar_t *dest = &src[2];// dest and src overlaps
	int count = 5;
	
	wmemmove(dest, src, count);
	wcout << L""After copying"" << endl;
	
	for(int i=0; i<count; i++)
		putwchar(dest[i]);
	
	return 0;
}","wchar_t* wmemmove( wchar_t* dest, const wchar_t* src, size_t count );","dest: Pointer to the wide character array where the contents are copied to
src: Pointer to the wide character array from where the contents are copied.
count: Number of wide characters to copy from src to dest.","After copying
αβγθλ",Cwchar
wmemcpy(),The wmemcpy() function in C++ copies a specified number of wide characters from source to the destination.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t src[] = L""\u03b1\u03b2\u03b3\u03b8\u03bb\u03c9\u03c0"";
	wchar_t dest[20];
	int count = 5;
	
	wmemcpy(dest, src, count);
	wcout << L""After copying"" << endl;
	
	for(int i=0; i<count; i++)
		putwchar(dest[i]);
	
	return 0;
}","wchar_t* wmemcpy( wchar_t* dest, const wchar_t* src, size_t count );","dest: Pointer to the wide character array where the contents are copied to
src: Pointer to the wide character array where the contents are copied from.
count: Number of wide characters to copy from src to dest.","After copying
αβγθλ",Cwchar
wmemcmp(),The wmemcmp() function in C++ compares a specified number of wide characters of two wide strings.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

void compare(wchar_t *lhs, wchar_t *rhs, int count)
{
	int result = wmemcmp(lhs, rhs, count);
	
	if(result > 0)
		wcout << rhs << L"" precedes "" << lhs << endl;
	else if (result < 0)
		wcout << lhs << L"" precedes "" << rhs << endl;
	else
		wcout << L""First "" << count << L"" characters of "" << lhs << L"" and "" << rhs << L"" are same"" << endl;
}

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");

	wchar_t lhs[] = L""\u0386\u03a6\u03aa\u03ac\u03c8\u03c9\u03ee"";
	wchar_t rhs[] = L""\u0386\u03a6\u03aa\u03ac\u03c0\u03c7\u03fb"";
	
	compare(lhs, rhs, 4);
	compare(lhs, rhs, 7);
	
	return 0;
}","int wmemcmp( const wchar_t* lhs, const wchar_t* rhs, size_t count );","lhs and rhs: Pointer to the wide character array to compare.
count: Maximum numbers of wide characters to compare.","First 4 characters of ΆΦΪάψωϮ and ΆΦΪάπχϻ are same
ΆΦΪάπχϻ precedes ΆΦΪάψωϮ",Cwchar
wcsxfrm(),The wcsxfrm() function in C++ transforms a given null terminated wide string into an implementation defined form.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_COLLATE, ""cs_CZ.UTF-8"");
	
	const wchar_t* s1 = L""\u0068\u0072\u006e\u0065\u0063"";
	const wchar_t* s2 = L""\u0063\u0068\u0072\u0074"";
	wchar_t t1[20], t2[20];
	
	cout << ""wcscoll returned "" << wcscoll(s1,s2) << endl;
	cout << ""Before transformation, "" << ""wcscmp returned "" << wcscmp(s1,s2) << endl;
	
	wcsxfrm(t1,s1,10);
	wcsxfrm(t2,s2,10);
	
	cout << ""After transformation, "" << ""wcscmp returned "" << wcscmp(t1,t2) << endl;
	return 0;
}","size_t wcsxfrm( wchar_t* dest, const wchar_t* src, size_t count );","dest: pointer to the array where the transformed wide string is stored.
src: pointer to the null terminated wide string to be transformed.
count: maximum number of wide characters to convert.","wcscoll returned -1
Before transformation, wcscmp returned 1
After transformation, wcscmp returned -1",Cwchar
wcsrchr(),The wcsrchr() function in C++ searches for the last occurrence of a wide character in a wide string.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t str[] = L""\u222b\u222e\u2231\u2211\u220f\u222b"";
	wchar_t ch = L'∫';// Integral sign
	wchar_t* p = wcsrchr(str, ch);
	
	if (p)
		wcout << L""Last position of "" << ch << L"" in \"""" << str << ""\"" is "" << (p-str);
	else
		wcout << ch << L"" is not present \"""" << str << L""\"""";
	
	return 0;
}","const wchar_t* wcsrchr( const wchar_t* str, wchar_t ch );
wchar_t* wcsrchr( wchar_t* str, wchar_t ch );","ptr: Pointer to the null terminated wide string to be searched for.
ch: Wide character to search for.","Last position of ∫ in ""∫∮∱∑∏∫"" is 5",Cwchar
wcspbrk(),The wcspbrk() function in C++ searches for a set of wide characters present in a wide string in another wide string.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t src[] = L""0123456789"";
	wchar_t dest[] = L""\u0126\u014b\u01b8\u0246\u006a\u0039\u00b5\u04c5\u0927\u0032\u1264"";
	wchar_t *s = wcspbrk(dest, src);
	int pos;
	
	if (s)
	{
		pos = s-dest;
		wcout << L""First occurrence of number in \"""" << dest << L""\"" is at position "" << pos << endl;
	}
	else
		wcout << L""No number found in \"""" << dest << ""\"""";
	
	return 0;
}","const wchar_t* wcspbrk( const wchar_t* dest, const wchar_t* str );
wchar_t* wcspbrk( wchar_t* dest, const wchar_t* str );","dest: Pointer to a null terminated wide string to be searched.
src: Pointer to a null terminated wide string containing the characters to search for.","First occurrence of number in ""ĦŋƸɆj9µӅध2ቤ"" is at position 5",Cwchar
wcsncpy(),The wcsncpy() function in C++ copies a specified number of wide characters from source to destination.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t src[] = L""\u0166\u0113\u010b\u0127\u0149\u0151\u013c\u014c\u0123\u0194"";
	wchar_t dest[] = L""Hello Hi"";
	
	wcout << L""Before copying, dest = "" << dest << endl;
	wcsncpy(dest, src, 4);
	
	wcout << L""After copying, dest = "" << dest << endl;
	return 0;
}","wchar_t *wcsncpy( wchar_t *dest, const wchar_t *src, size_t count );","dest: Pointer to a wide character array where the contents are copied to.
src: Pointer to a wide character array where the contents are copied from.
count: Maximum number of wide characters to copy.","Before copying, dest = Hello Hi
After copying, dest = Ŧēċħo Hi",Cwchar
wcsncmp(),The wcsncmp() function in C++ compares a specified number of wide characters of two null terminating wide strings. The comparison is done lexicographically.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

void compare(wchar_t *lhs, wchar_t *rhs, int count)
{
	int result;
	result = wcsncmp(lhs, rhs, count);

	if(result > 0)
		wcout << rhs << "" precedes "" << lhs << endl;
	else if (result < 0)
		wcout << lhs << "" precedes "" << rhs << endl;
	else
		wcout << L""First "" << count << L"" characters of "" << lhs << L"" and "" << rhs <<L"" are same"" << endl;
}

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t str1[] = L""\u0166\u0113\u010b\u0127\u0149\u0151\u013c\u014c\u0123\u0194"";
	wchar_t str2[] = L""Ŧēċħnology"";
	
	compare(str1,str2,4);
	compare(str1,str2,7);
	
	return 0;
}","int wcsncmp( const wchar_t* lhs, const wchar_t* rhs, size_t count );","lhs: Pointer to one of the null terminated wide strings to compare.
rhs: Pointer to one of the null terminated wide strings to compare.
count: Maximum number of wide characters to compare.","First 4 characters of ŦēċħŉőļŌģƔ and Ŧēċħnology are same
Ŧēċħnology precedes ŦēċħŉőļŌģƔ",Cwchar
wcsncat(),The wcsncat() function in C++ appends a specified number of wide characters of a wide string to the end of another wide string.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t src[] = L""\u0410\u0411\u0412\u0413\u0415\u0416\u0417\u0418"";
	wchar_t dest[] = L""\u0424\u0425\u0426\u0427\u0428\u0429"";
	
	wcout << L""Before appending, dest = "" << dest << endl;
	wcsncat(dest, src, 4);
	
	wcout << L""After appending, dest = "" << dest << endl;
	return 0;
}","wchar_t *wcsncat( wchar_t *dest, const wchar_t *src, size_t count );","dest: Pointer to a null terminating wide string to append to.
src: Pointer to a null terminating wide string that is to be appended.
count: Maximum numbers of wide characters to copy.","Before appending, dest = ФХЦЧШЩ
After appending, dest = ФХЦЧШЩАБВГ",Cwchar
wcslen(),The wcslen() function in C++ returns the length of the given wide string.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t str1[] = L""Hello World\u0021"";
	wchar_t str2[] = L""\u0764\u077a\u077c\u079f\u07a1\u072e"";
	int len1 = wcslen(str1);
	int len2 = wcslen(str2);
	
	cout << ""Length of str1 = "" << len1 << endl;
	cout << ""Length of str2 = "" << len2 << endl;
	if (len1 > len2)
		cout << ""str1 is longer than str2"";
	else if (len1 < len2)
		cout << ""str2 is longer than str1"";
	else
		cout << ""str1 and str2 are of equal length"";
	
	return 0;
}",size_t wcslen( const wchar_t* str );,str: Pointer to the null terminated wide string whose length is to be calculated.,"Length of str1 = 12
Length of str2 = 6
str1 is longer than str2",Cwchar
wcscspn(),The wcscspn() function in C++ searches and returns the number of wide characters before the first occurrence of any wide character in the given wide string.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t src[] = L""0123456789"";
	wchar_t dest[] = L""\u222b\u0028\u0078\u002b\u0032\u0029\u0064\u0078"";
	int result = wcscspn(dest, src);
	
	if (result < wcslen(dest))
		wcout << L""First occurrence of number in "" << dest << "" is at position "" << result;
	else
		wcout << dest << L"" does not contain numbers"";
	
	return 0;
}","size_t wcscspn( const wchar_t* dest, const wchar_t* src );","dest: Pointer to a null terminated wide string to be searched.
src: Pointer to a null terminated wide string containing the characters to search for.",First occurrence of number in ∫(x+2)dx is at position 4,Cwchar
wcscpy(),The wcscpy() function in C++ copies a wide character string from source to destination.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t src[] = L""\u0102\u0070ple"";
	wchar_t dest[20];
	
	wcscpy(dest,src);
	wcout << L""After copying, dest = "" << dest;
	
	return 0;
}","wchar_t *wcscpy( wchar_t *dest, const wchar_t *src );","dest: Pointer to a wide character array where the contents are copied to.
src: Pointer to a wide character array where the contents are copied from.","After copying, dest = Ăpple",Cwchar
wcscat(),The wcscat() function in C++ appends a copy of a wide string to the end of another wide string.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t dest[50] = L""\u0905 \u0906 \u0907 \u0908 "";
	wchar_t src[50] = L""\u0915 \u0916 \u0917 \u0918 "";
	
	wcscat(dest, src);
	wcout << ""After appending: "" << dest ;
	
	return 0;
}","wchar_t* wcscat( wchar_t* dest, const wchar_t* src );","dest: Pointer to a null terminating wide string to append to.
src: Pointer to a null terminating wide string that is to be appended.",After appending: अ आ इ ई क ख ग घ,Cwchar
wcsrtombs(),The wcsrtombs() function in C++ converts a wide character sequence to a narrow multibyte character sequence.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	const wchar_t* wstr = L""\u0763\u0757\u077f\u075f"";
	char str[20];
	mbstate_t ps = mbstate_t();
	
	int len = 10;
	int retVal;
	
	retVal = wcsrtombs(str, &wstr, len, &ps);
	cout << ""Number of multibyte characters written (excluding \""\\0\"") = "" << retVal << endl;
	cout << ""Multibyte character = "" << str << endl;
	
	return 0;
}","size_t wcsrtombs( char* dest, const wchar_t** src, size_t len, mbstate_t* ps );",">dest: Pointer to the character array where the converted multibyte character is stored.
src: Pointer to pointer to the first wide character to convert.
len: Maximum number of bytes available in dest array.
ps: Pointer to the conversion state object.","Number of multibyte characters written (excluding ""\0"") = 8
Multibyte character = ݣݗݿݟ",Cwchar
wctob(),The wctob() function in C++ converts a wide character to a single byte character (of type char) if its multibyte character equivalent is a single byte.,"#include <cwchar>
#include <clocale>
#include <iostream>
#include <cstdio>
using namespace std;

void test_wctob(wchar_t c)
{
	int ch = wctob(c);
	if (ch != EOF)
		wcout << c << L"" can be narrowed"" << endl;
	else
		wcout << c << L"" can't be narrowed"" << endl;
}

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");

	wchar_t wc1 = L'm';
	wchar_t wc2 = L'\u00c6';
	
	test_wctob(wc1);
	test_wctob(wc2);
	
	return 0;
}",int wctob( wint_t c );,c: The wide character to narrow.,"m can be narrowed
Æ can't be narrowed",Cwchar
wcrtomb(),The wcrtomb() function in C++ converts a wide character to its narrow multibyte representation.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t str[] = L""u\u00c6\u00f5\u01b5"";
	char s[16];
	int retVal;
	
	mbstate_t ps = mbstate_t();
	for (int i=0; i<wcslen(str); i++)
	{
		retVal = wcrtomb(s, str[i], &ps);
		if (retVal!=-1)
		cout << ""Size of "" << s << "" is "" << retVal << "" bytes"" << endl;
		else
		cout << ""Invalid wide character"" << endl;
	}
	
	return 0;
}","size_t wcrtomb( char* s, wchar_t wc, mbstate_t* ps );","s: Pointer to the multibyte character array to store the result.
wc: Wide character to convert.
ps: Pointer to the conversion state used when interpreting the multibyte string","Size of u is 1 bytes
Size of Æ is 2 bytes
Size of õ is 2 bytes
Size of Ƶ is 2 bytes",Cwchar
mbsrtowcs(),The mbsrtowcs() function in C++ converts a narrow multibyte character sequence to a wide character sequence (of type wchar_t).,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	const char* str = ""\u0763\u0757\u077f\u075f"";
	wchar_t wstr[20];
	
	mbstate_t ps = mbstate_t();
	int len = 10;
	int retVal;
	
	retVal = mbsrtowcs(wstr, &str, len, &ps);
	wcout << L""Number of wide characters written (excluding L\""\\0\"") = "" << retVal << endl;
	wcout << L""Wide character = "" << wstr << endl;
	
	return 0;
}","size_t mbsrtowcs( wchar_t* dest, const char** src, size_t len, mbstate_t* ps );","dest: Pointer to the array where the converted wide character is stored.
src: Pointer to pointer to the first multibyte character to convert.
len: Maximum number wide character to store.
ps: Pointer to the conversion state used when interpreting the multibyte string","Number of wide characters written (excluding L""\0"") = 4
Wide character = ݣݗݿݟ",Cwchar
mbsinit(),The mbsinit() function in C++ determines whether an mbstate_t object describes the initial conversion state.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

void test_ps(mbstate_t ps)
{
	if (mbsinit(&ps))
	cout << ""the conversion state is initial conversion state"" << endl;
	else
	cout << ""the conversion state is not initial conversion state"" << endl;
}

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	char str[] = ""\u00b5"";
	mbstate_t ps = mbstate_t();
	
	cout << ""Initially after creating ps, "";
	test_ps(ps);
	mbrlen(str, 1, &ps);
	
	cout << ""After performing some task, "";
	test_ps(ps);
	
	return 0;
}",int mbsinit( const mbstate_t* ps);,ps: Pointer to an mbstate_t object to inspect.,"Initially after creating ps, the conversion state is initial conversion state
After performing some task, the conversion state is not initial conversion state",Cwchar
mbrtowc(),The mbrtowc() function in C++ converts a narrow multibyte character to a wide character (of type wchar_t).,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

void test_mbrtowc(const char *s, size_t n)
{
	mbstate_t ps = mbstate_t();
	wchar_t wc;
	int retVal = mbrtowc(&wc, s, n, &ps);
	
	if (retVal == -2)
		wcout << L""Next "" << n << L"" byte(s) doesn't represent a complete multibyte character"" << endl;
	else if (retVal == -1)
		wcout << L""Next "" << n << L"" byte(s) doesn't represent a valid multibyte character"" << endl;
	else if (retVal == 0)
		wcout << L""The converted wide character is a null wide character"" << endl;
	else
	{
		wcout << L""Next "" << n << L"" byte(s) hold "" << retVal << L"" bytes of multibyte character, "";
		wcout << L""Resulting wide character is "" << wc << endl;
	}
}

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	char str1[] = ""\u00b5"";
	char str2[] = ""\0"";
	
	test_mbrtowc(str1, 1);
	test_mbrtowc(str1, 5);
	test_mbrtowc(str2, 5);
	
	return 0;
}","size_t mbrtowc( wchar_t* pwc, const char* s, size_t n, mbstate_t* ps );","pwc: Pointer to the memory address where the converted wide character is stored.
s: Pointer to the multibyte character to convert.
n: Maximum number of bytes in s to examine.
ps: Pointer to the conversion state used when interpreting the multibyte string","Next 1 byte(s) doesn't represent a complete multibyte character
Next 5 byte(s) hold 2 bytes of multibyte character, Resulting wide character is µ
The converted wide character is a null wide character",Cwchar
mbrlen(),The mbrlen() function in C++ determines the size in bytes of a multibyte character.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

void test_mbrlen(const char *s, size_t n)
{
	mbstate_t ps = mbstate_t();
	int retVal = mbrlen(s, n, &ps);

	if (retVal == -2)
		cout << ""Next "" << n << "" byte(s) doesn't represent a complete multibyte character"" << endl;
	else if (retVal == -1)
		cout << ""Next "" << n << "" byte(s) doesn't represent a valid multibyte character"" << endl;
	else
		cout << ""Next "" << n << "" byte(s) of "" << s << "" holds "" << retVal << "" byof multibyte character"" << endl;
}

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	char str[] = ""\u00b5"";

	test_mbrlen(str, 1);
	test_mbrlen(str, 5);

	return 0;
}","size_t mbrlen( const char* s, size_t n, mbstate_t* ps);","s: Pointer to the first byte of multibyte string to examine.
n: MAximum number of bytes in s to examine.
ps: Pointer to mbstate_t object that defines a conversion state.","Next 1 byte(s) doesn't represent a complete multibyte character
Next 5 byte(s) of µ holds 2 bytes of multibyte character",Cwchar
btowc(),The btowc() function in C++ converts a character to its wide character equivalent.,"#include <cwchar>
#include <cstring>
#include <iostream>
using namespace std;

int main()
{
	char str[] = ""Hello\xf4\xdf"";
	wchar_t wc;
	int count = 0;
	
	for (int i=0; i<strlen(str); i++)
	{
		wc = btowc(str[i]);
		if (wc != WEOF)
		count++;
	}
	
	cout << count << "" out of "" << strlen(str) << "" characters were successfully widened"";
	return 0;
}",wint_t btowc( int c );,c: The single byte character to convert to wide character.,5 out of 7 characters were successfully widened,Cwchar
wcstok(),The wcstok() function in C++ returns the next token in a null terminated wide string.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.utf8"");
	
	wchar_t str[] = L""parrot,owl,sparrow,pigeon,crow"";
	wchar_t delim[] = L""\u002c"";// unicode for comma
	wchar_t *ptr;
	
	wcout << L""The tokens are:"" << endl;
	wchar_t *token = wcstok(str,delim,&ptr);
	
	while (token)
	{
		wcout << token << endl;
		token = wcstok(NULL,delim,&ptr);
	}
	
	return 0;
}","wchar_t* wcstok( wchar_t* str, const wchar_t* delim, wchar_t ** ptr);","str: Pointer to the null terminated wide string to tokenize.
delim: Pointer to the null terminated wide string that contains the separators.
ptr: Pointer to a pointer to a wide character which is used by wcstok to store its internal state.","The tokens are:
parrot
owl
sparrow
pigeon
crow",Cwchar
wcstold(),The wcstold() function in C++ interprets the contents of a wide string as a floating point number and return its value as a long double.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t str[] = L""93.410\u03b7\u05ea"";
	wchar_t *end;
	long double value;
	
	value = wcstold(str,&end);
	wcout << L""Wide String = "" << str << endl;
	wcout << L""Long Double value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	return 0;
}","long double wcstold( const wchar_t* str, wchar_t** str_end );","str: A wide string having the representation of a floating point number.
str_end: Pointer to a pointer to a wide character. The value of str_end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer.","Wide String = 93.410ηת
Long Double value = 93.41
End String = ηת",Cwchar
wcstol(),The wcstol() function in C++ interprets the contents of a wide string as an integral number of the specified base and returns its value as a long int.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	
	wchar_t str1[] = L""101aa\u16b6"";
	wchar_t str2[] = L""59"";
	wchar_t *end;
	long value;
	int base = 10;
	
	value = wcstol(str1, &end, base);
	wcout << L""String value = "" << str1 << endl;
	wcout << L""Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	value = wcstol(str2, &end, base);
	wcout << L""String value = "" << str2 << endl;
	wcout << L""Long Int value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	return 0;
}","long wcstol( const wchar_t* str, wchar_t** str_end, int base );","str: A wide string having the representation of an integral number.
str_end: A pointer to a pointer to a wide character. The value of str_end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer, in which case it is not used.
base: The base of the integral value. The set of valid values for base is {0, 2, 3, …, 35, 36}.","String value = 101aaᚶ
Long Int value = 101
End String = aaᚶ
String value = 59
Long Int value = 59
End String =",Cwchar
wcstof(),The wcstof() function in C++ interprets the contents of a wide string as a floating point number and return its value as a float.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");

	wchar_t str[] = L""40.001\u220fc12"";
	wchar_t *end;
	float value;
	value = wcstof(str,&end);

	wcout << L""Wide String = "" << str << endl;
	wcout << L""Float value = "" << value << endl;
	wcout << L""End String = "" << end << endl;

	return 0;
}","float wcstof( const wchar_t* str, wchar_t** str_end );","str: A wide string having the representation of a floating point number.
str_end: Pointer to a pointer to a wide character. The value of str_end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer.","Wide String = 40.001∏c12
Float value = 40.001
End String = ∏c12",Cwchar
wcstod(),The wcstod() function in C++ interprets the contents of a wide string as a floating point number and return its value as a double.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t str[] = L""83.201xz\u0496\u0687"";

	wchar_t *end;
	double value;
	value = wcstod(str,&end);

	wcout << L""Wide String = "" << str << endl;
	wcout << L""Double value = "" << value << endl;
	wcout << L""End String = "" << end << endl;
	
	return 0;
}","double wcstod( const wchar_t* str, wchar_t** str_end );","str: A wide string having the representation of a floating point number.
str_end: Pointer to a pointer to a wide character. The value of str_end is set by the function to the next character in str after the last valid character. This parameter can also be a null pointer.","Wide String = 83.201xzҖڇ
Double value = 83.201
End String = xzҖڇ",Cwchar
wscanf(),The wscanf() function in C++ reads wide character from stdin.,%[*][width][length]specifier,"int wscanf( const char* format, ... );","format: Pointer to a null-terminated character string that specifies how to read the input. It consists of format specifiers starting with %.
		The format string has the following parts:
		
Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, wscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that wscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.




Format specifiers


Format Specifier
Description




%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[*][width][length]specifier

… : Other additional arguments for receiving data. They occur in a sequence according to the format specifier.","Enter a wide character: ∭
∭ is not alphanumeric.",Cwchar
wprintf(),The wprintf() function in C++ is used to write a formatted wide string to stdout.,%[flags][width][.precision][length]specifier,"int wprintf( const wchar_t* format, ... );","format: A pointer to a null terminated wide string that is written to stdout. It consists of wide characters along with optional format specifiers starting with %. The format specifiers are replaced by the values of respective variables that follows format.
		The format specifier has the following parts:
		
A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:


Format specifiers


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[flags][width][.precision][length]specifier

… : Other additional arguments specifying the data to be printed. They occur in a sequence according to the format specifier.","x = 5
Hello André",Cwchar
vwscanf(),The vwscanf() function in C++ is used to read wide character string from stdin.,%[*][width][length]specifier,"int vwscanf( const wchar_t* format, va_list vlist );","format: Pointer to a null-terminated wide character string that specifies how to read the input. It consists of format specifiers starting with %.
		The format string has the following parts:
		
Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, vwscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that vwscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.




Format specifiers


Format Specifier
Description




%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[*][width][length]specifier

vlist: A list of arguments for receiving the inputs.","What is your name? Götz
Hello Götz",Cwchar
vwprintf(),The vwprintf() function in C++ is used to write a formatted wide string to stdout.,%[flags][width][.precision][length]specifier,"int vwprintf( const wchar_t* format, va_list vlist );","format: A pointer to a null terminated wide string that is written to stdout. It consists of characters along with optional format specifiers starting with %. The format specifiers are replaced by the values of respective variables that follows format.
		The format specifier has the following parts:
		
A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:


Format specifiers


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[flags][width][.precision][length]specifier

vlist: A list of arguments containing the data to print.","Some Greek Letters
Eta : η
Theta : θ
Iota : ι
Kappa : κ
Lamda : λ",Cwchar
vswscanf(),The vfwscanf() function in C++ is used to read wide character string from a wide string bufffer.,%[*][width][length]specifier,"int vswscanf( const wchar_t* buffer, const wchar_t* format, va_list vlist );","buffer: Pointer to the null terminated wide string to read the data from.
format: Pointer to a null-terminated wide character string that specifies how to read the input. It consists of format specifiers starting with %.
		The format string has the following parts:
		
Non whitespace characters except % each of which consumes one identical character from the input stream. It can cause the function to fail if the next character on the stream does not compare equal.
Whitespace character: All the consecutive whitespace characters are treated as single whitespace character. Further, '\n', '\t' and ' ' are considered same.
Conversion specification: It follows the following format:
				
Initial % character that specifies the beginning
An optional * called assignment-suppressing character. If this character is present, vfwscanf() does not assign the result to any receiving argument.
An optional positive integer number that specifies maximum field width. It specifies the maximum number of characters that vfwscanf() is allowed to consume when doing the conversion specified by the current conversion specification.
An optional length modifier specifying the size of the receiving argument.
A conversion format specifier.




Format specifiers


Format Specifier
Description




%
Matches the literal %


c
Matches a single character or multiple characters. If width is defined, matches exactly width characters.


s
Matches consecutive non whitespace characters. If width is defined, matches exactly width characters or until first whitespace is found.


[set]
Matches a non empty sequence of character from the given set of characters. If ^ is present at the beginning of set, then all the characters not in set are matched.


d
Matches a decimal integer.


i
Matches an integer.


o
Matches an unsigned octal integer.


X or x
Matches an unsigned hexadecimal integer.


u
Matches an unsigned decimal integer.


A or a, E or e, F or f, G or g
Matches a floating-point number.


n
Returns the number of characters read so far.


p
Matches an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[*][width][length]specifier

vlist: A list of arguments for receiving the inputs.","Random Symbols
࿗
Æ
₹
℧
៘",Cwchar
vswprintf(),The vswprintf() function in C++ is used to write a formatted wide string to a wide string buffer.,%[flags][width][.precision][length]specifier,"int vswprintf( wchar_t* buffer, size_t buf_size, const wchar_t* format, va_list vlist );","buffer: Pointer to a wide string buffer to write the result.
buf_size: Maximum number of wide characters to write including the terminating null wide character.
format: A pointer to a null terminated wide string that is written to buffer. It consists of characters along with optional format specifiers starting with %. The format specifiers are replaced by the values of respective variables that follows format.
		The format specifier has the following parts:
		
A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:


Format specifiers


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[flags][width][.precision][length]specifier

vlist: A list of arguments containing the data to write.",Arabic Letters: ڄ ڱ ڪ ڣ ڄ,Cwchar
vfwprintf(),The vfwprintf() function in C++ is used to write a formatted wide string to a file stream.,%[flags][width][.precision][length]specifier,"int vfwprintf( FILE* stream, const wchar_t* format, va_list vlist );","stream: Output file stream to write the result.
format: A pointer to a null terminated wide string that is written to stream. It consists of characters along with optional format specifiers starting with %. The format specifiers are replaced by the values of respective variables that follows format.
		The format specifier has the following parts:
		
A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:


Format specifiers


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[flags][width][.precision][length]specifier

vlist: A list of arguments containing the data to write.","Some Greek Letters
Eta : η
Theta : θ
Iota : ι
Kappa : κ
Lamda : λ",Cwchar
ungetwc(),The ungetwc() function in C++ push the previously read wide character back to the stream so that it could be read again.,"#include <cwchar>
#include <clocale>
#include <cwctype>
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");

	wint_t c;
	long value = 0;
	wchar_t str[] = L""\u0037\u0031\u0039\u00b6\u03ee"";
	FILE *fp = fopen(""file.txt"", ""r+"");

	fputws(str,fp);
	rewind(fp);
	while(1)
	{
		c = fgetwc(fp);
		if (iswdigit(c))
		value = value*10 + c - L'0';
		else
		break;
	}
	ungetwc(c, fp);

	cout << ""Value = "" << value << endl;
	fclose(fp);
	return 0;
}","wint_t ungetwc( wint_t ch, FILE* stream );","ch: The wide character to be pushed back.
stream: File stream where the wide character is pushed back.",Value = 719,Cwchar
swprintf(),The swprintf() function in C++ is used to write a formatted wide string to a wide string buffer.,%[flags][width][.precision][length]specifier,"int swprintf( wchar_t* buffer, size_t size, const wchar_t* format, ... );","buffer: Pointer to the string buffer to write the result.
size: Specify maximum number of characters to be written to buffer which is size-1.
format: A pointer to a null terminated wide string that is written to stdout. It consists of wide characters along with optional format specifiers starting with %. The format specifiers are replaced by the values of respective variables that follows format.
		The format specifier has the following parts:
		
A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:


Format specifiers


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.




		So the general format of format specifier is:
		
%[flags][width][.precision][length]specifier

… : Other additional arguments specifying the data to be written. They occur in a sequence according to the format specifier.","Some hebrew letters
א ב ס ד ת",Cwchar
putwchar(),The putwchar() function in C++ writes a wide character to stdout.,"#include <cwchar>
#include <clocale>
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, ""en_US.UTF-8"");
	wchar_t start = L'\u05d0', end = L'\u05ea';
	wcout << L""Hebrew Alphabets"" << endl;

	for (wchar_t i=start; i<=end; i++)
	{
		putwchar(i);
		putwchar(' ');
	}
	
	return 0;
}",wint_t putwchar(wchar_t ch);,ch: The wide character to be written.,"Hebrew Alphabets
א ב ג ד ה ו ז ח ט י ך כ ל ם מ ן נ ס ע ף פ ץ צ ק ר ש ת",Cwchar
getwchar(),The getwchar() function in C++ reads the next wide character from stdin.,"#include <iostream>
#include <cwchar>
#include <clocale>
using namespace std;

int main()
{
	int i=0;
	wchar_t c;
	wchar_t str[100];

	setlocale(LC_ALL, ""en_US.UTF-8"");
	wcout << L""Enter characters, Press Enter to stop\n"";
	do
	{
		c = getwchar();
		str[i] = c;
		i++;
	}while(c!=L'\n');

	wcout << L""You entered : "" << str;
	return 0;
}",wint_t getwchar();,None.,"Enter characters, Press Enter to stop
äs12 ɏ
You entered : äs12 ɏ",Cwchar
fwprintf(),The fwprintf() function in C++ is used to write a formatted wide string to a file stream.,%[flags][width][.precision][length]specifier,"int fwprintf( FILE* stream, const wchar_t* format, ... );","stream: Pointer to an output file stream where the contents are written.
format: A pointer to a null terminated wide string that is written to stdout. It consists of wide characters along with optional format specifiers starting with %. The format specifiers are replaced by the values of respective variables that follows format.
		The format specifier has the following parts:
		
A leading % sign
Flags: Optional one or more flags that modifies the conversion behavior.
				
- : Left justify the result within the field. By default it is right justified.
+ : The sign of the result is attached to the beginning of the value, even for positive results.
Space: If there is no sign, a space is attached to the beginning of the result.
# : An alternative form of the conversion is performed.
0 : It is used for integer and floating point number. Leading zeros are used to pad the numbers instead of space.


Width: An optional * or integer value used to specify minimum width field.
Precision : An optional field consisting of a . followed by * or integer or nothing to specify the precision.
Length : An optional length modifier that specifies the size of the argument.
Specifier: A conversion format specifier. The available format specifiers are as follows:


Format specifiers


Format Specifier
Description




%
Prints %


c
Writes a single character


s
Writes a character string


d or i
Converts a signed integer to decimal representation


o
Converts an unsigned integer to octal representation


X or x
Converts an unsigned integer to hexadecimal representation


u
Converts an unsigned integer to decimal representation


F or f
Converts floating-point number to the decimal representation


E or e
Converts floating-point number to the decimal exponent notation


A or a
Converts floating-point number to the hexadecimal exponent


G or g
Converts floating-point number to either decimal or decimal exponent notation


n
Returns the number of characters written so far by this call to the function. The result is written to the value pointed to by the argument


p
Writes an implementation defined character sequence defining a pointer.



		So the general format of format specifier is:

		
%[flags][width][.precision][length]specifier

… : Other additional arguments specifying the data to be written. They occur in a sequence according to the format specifier.",Here are some Hebrew letters: א ב ס ד ת,Cwchar
fwide(),The fwide() function in C++ either attempts to set the orientation or queries the current orientation of a given file stream.,"#include <cwchar>
#include <cstdio>
#include <iostream>
using namespace std;

int main()
{
	FILE *fp;
	int retVal;

	fp = fopen(""file.txt"",""r"");
	retVal = fwide(fp,0);
	if (retVal == 0)
		cout << ""Stream has no orientation"" << endl;
	else if (retVal > 0)
		cout << ""Stream is wide-oriented"" << endl;
	else
		cout << ""Stream is byte-oriented"" << endl;

	/* wide oriented stream */
	cout << ""Setting stream to wide-orientation"" << endl;
	retVal = fwide(fp,1);
	if (retVal == 0)
		cout << ""Stream has no orientation"" << endl;
	else if (retVal > 0)
		cout << ""Stream is wide-oriented"" << endl;
	else
		cout << ""Stream is byte-oriented"" << endl;

	return 0;
}","int fwide( FILE* stream, int mode );","stream: Pointer to the file stream to set or query the orientation.
mode: An integer value that determines whether to set or query the orientation of the stream.","Stream has no orientation
Setting stream to wide-orientation
Stream is wide-oriented",Cwchar
mbrtoc32(),The mbrtoc32() function in C++ converts a narrow multibyte character to a 32 bit character representation.,"#include <cstdio>
#include <cstdlib>
#include <cuchar>
#include <iostream>
using namespace std;

int main(void)
{
	char32_t pc32;
	char s[] = ""x"" ;
	mbstate_t ps;
	int length;

	length = mbrtoc32(&pc32, s, MB_CUR_MAX, &ps);
	if (length < 0)
	{
		perror(""mbrtoc32() fails to convert"");
		exit(-1);
	}

	cout << ""Multibyte string = "" << s << endl;
	cout << ""Length = "" << length << endl;
	printf (""32-bit character = 0x%08hx\n"", pc32);

	return 0;
}","size_t mbrtoc32( char32_t* pc32, const char* s, size_t n, mbstate_t* ps);","pc32: Pointer to the memory location to store the resulting 32 bit character.
s: Pointer to the multibyte character to convert.
n: Maximum number of bytes in s to convert.
ps: A pointer to an mbstate_t object used when interpreting the multibyte string.","Multibyte string = x
Length = 1
32-bit character = 0x00000078",Cuchar
mbrtoc16(),The mbrtoc16() function in C++ converts a narrow multibyte character to a 16 bit character representation.,"#include <cstdio>
#include <cstdlib>
#include <cuchar>
#include <iostream>
using namespace std;

int main(void)
{
	char16_t pc16;
	char s[] = ""x"" ;
	mbstate_t ps{};
	int length;

	length = mbrtoc16(&pc16, s, MB_CUR_MAX, &ps);

	if (length < 0)
	{
		perror(""mbrtoc16() fails to convert"");
		exit(-1);
	}

	cout << ""Multibyte string = "" << s << endl;
	cout << ""Length = "" << length << endl;
	printf (""16-bit character = 0x%04hx\n"", pc16);

	return 0;
}","size_t mbrtoc16( char16_t* pc16, const char* s, size_t n, mbstate_t* ps);","pc16: Pointer to the memory location to store the resulting 16 bit character.
s: Pointer to the multibyte character to convert.
n: Maximum number of bytes in s to convert.
ps: A pointer to an mbstate_t object used when interpreting the multibyte string.","Multibyte string = x
Lengt>h = 1
16-bit character = 0x0078",Cuchar
c32rtomb(),The c32rtomb() function in C++ converts a 32 bit character to representation to a narrow multibyte character representation.,"#include <cuchar>
#include <iostream>
using namespace std;

int main()
{
	const char32_t str[] = U""C++ is super fast."";
	char s[50];
	mbstate_t ps{};
	size_t length;
	int j = 0;

	while (str[j])
	{
		length = c32rtomb(s, str[j], &ps);
		if ((length == 0) || (length > 50))
			break;

		for (int i=0; i<length; ++i)
			cout << s[i];
		++j;
	}

	return 0;
}","size_t c32rtomb(char* s, char32_t c32, mbstate_t* ps);","s: Pointer to a character array where the multibyte character is stored.
c32: The 32 bit character to convert.
ps: A pointer to an mbstate_t object used when interpreting the multibyte string.",C++ is super fast.,Cuchar
c16rtomb(),The c16rtomb() function in C++ converts 16 bit character representation to a narrow multibyte character representation.,"#include <cuchar>
#include <iostream>
using namespace std;

int main()
{
	const char16_t str[] = u""Hello World!"";
	char s[50];
	mbstate_t ps{};
	size_t length;
	int j = 0;

	while (str[j])
	{
		length = c16rtomb(s, str[j], &ps);
		if ((length == 0) || (length > 50))
			break;
		for (int i=0; i<length; ++i)
			cout << s[i];
		++j;
	}

	return 0;
}","size_t c16rtomb(char* s, char16_t c16, mbstate_t* ps);","s: Pointer to a character array where the multibyte character is to be stored.
c16: The 16 bit character to convert.
ps: A pointer to an mbstate_t object used when interpreting the multibyte string.",Hello World!,Cuchar
longjmp() and setjmp(),The longjmp() function in C++ restores the environment previously saved by calling setjmp().,"#include <iostream>
#include <csetjmp>
using namespace std;

int main()
{
	jmp_buf env;
	int val;
	
	val = setjmp(env);
	if (val==0)
	{
		cout << ""setjmp returned "" << val << endl;
		longjmp(env,val);
	}
	else
	{
		cout << ""setjmp returned "" << val << endl;
		cout << ""Program terminating"" << endl;
	}

	return 0;
}","void longjmp(jmp_buf env, int status);","env: An object of type jmp_buf that stores the environment to load.
status: The variable to return from setjmp. If it is equal to 0, 1 is used instead.","setjmp returned 0
setjmp returned 1
Program terminating",Csetjmp
fetestexcept(),The fetestexcept() function in C++ determines which of the specified subset of the floating point exceptions are currently set.,"#include <iostream>
#include <cmath>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_exceptions()
{
	cout << ""Raised exceptions: "";
	if(fetestexcept(FE_ALL_EXCEPT))
	{
		if(fetestexcept(FE_DIVBYZERO))
			cout << ""FE_DIVBYZERO "";
		if(fetestexcept(FE_INEXACT))
			cout << ""FE_INEXACT "";
		if(fetestexcept(FE_INVALID))
			cout << ""FE_INVALID "";
		if(fetestexcept(FE_OVERFLOW))
			cout << ""FE_OVERFLOW "";
		if(fetestexcept(FE_UNDERFLOW))
			cout << ""FE_UNDERFLOW "";
	}
	else
		cout << ""None"";

	cout << endl;
}

int main(void)
{
	print_exceptions();
	
	feraiseexcept(FE_INVALID|FE_DIVBYZERO);
	print_exceptions();

	feclearexcept(FE_ALL_EXCEPT);
	print_exceptions();
	
	return 0;
}",int fetestexcept( int excepts );,excepts: Bitmask listing the exception flags to test.,"Raised exceptions: None
Raised exceptions: FE_DIVBYZERO FE_INVALID
Raised exceptions: None",Cfenv
feupdateenv(),"The feupdateenv() function first saves currently raised floating-point exceptions, restores the floating-point environment from the given fenv_t object, then raises the exceptions saved previously.","#include <iostream>
#include <cmath>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_exceptions()
{
	cout << ""Raised exceptions: "";
	if(fetestexcept(FE_ALL_EXCEPT))
	{
		if(fetestexcept(FE_DIVBYZERO))
			cout << ""FE_DIVBYZERO "";
		if(fetestexcept(FE_INEXACT))
			cout << ""FE_INEXACT "";
		if(fetestexcept(FE_INVALID))
			cout << ""FE_INVALID "";
		if(fetestexcept(FE_OVERFLOW))
			cout << ""FE_OVERFLOW "";
		if(fetestexcept(FE_UNDERFLOW))
			cout << ""FE_UNDERFLOW "";
	}
	else
		cout << ""None"";

	cout << endl;
}

int main()
{
	fenv_t envp;

	/* raise certain exceptions */
	feraiseexcept(FE_INVALID|FE_DIVBYZERO);
	print_exceptions();
	
	/* saves and clears current exceptions */
	feupdateenv(&envp);
	print_exceptions();
	
	/* restores saved exceptions */
	feupdateenv(&envp);
	print_exceptions();
	
	return 0;
}",int feupdateenv( fenv_t* envp );,envp: Pointer to the fenv_t object that is set by an earlier call to feholdexcept or fegetenv or is equal to FE_DFL_ENV.,"Raised exceptions: FE_DIVBYZERO FE_INVALID
Raised exceptions: None
Raised exceptions: FE_DIVBYZERO FE_INVALID",Cfenv
feholdexcept(),The feholdexcept() function in C++ first saves the current floating point environment to a fenv_t object and then clears all the floating point status flags.,"#include <iostream>
#include <cmath>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_exceptions()
{
	cout << ""Raised exceptions: "";
	if(fetestexcept(FE_ALL_EXCEPT))
	{
		if(fetestexcept(FE_DIVBYZERO))
			cout << ""FE_DIVBYZERO "";
		if(fetestexcept(FE_INEXACT))
			cout << ""FE_INEXACT "";
		if(fetestexcept(FE_INVALID))
			cout << ""FE_INVALID "";
		if(fetestexcept(FE_OVERFLOW))
			cout << ""FE_OVERFLOW "";
		if(fetestexcept(FE_UNDERFLOW))
			cout << ""FE_UNDERFLOW "";
	}
	else
		cout << ""None"";

	cout << endl;
}

int main(void)
{
	fenv_t envp;

	/* raise certain exceptions */
	feraiseexcept(FE_INVALID|FE_DIVBYZERO);
	print_exceptions();
	
	/* saves and clears current exceptions */
	feholdexcept(&envp);
	print_exceptions();
	
	/* restores saved exceptions */
	feupdateenv(&envp);
	print_exceptions();

	return 0;
}",int feholdexcept( fenv_t* envp );,envp: Pointer to an object of type fenv_t that stores the status of the floating point environment.,"Raised exceptions: FE_DIVBYZERO FE_INVALID
Raised exceptions: None
Raised exceptions: FE_DIVBYZERO FE_INVALID",Cfenv
fesetenv(),The fesetenv() function in C++ attempts to set the floating-point environment from the given pointer object of type fenv_t.,"#include <iostream>
#include <cmath>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_exceptions()
{
	cout << ""Raised exceptions: "";
	if(fetestexcept(FE_ALL_EXCEPT))
	{
		if(fetestexcept(FE_DIVBYZERO))
			cout << ""FE_DIVBYZERO "";
		if(fetestexcept(FE_INEXACT))
			cout << ""FE_INEXACT "";
		if(fetestexcept(FE_INVALID))
			cout << ""FE_INVALID "";
		if(fetestexcept(FE_OVERFLOW))
			cout << ""FE_OVERFLOW "";
		if(fetestexcept(FE_UNDERFLOW))
			cout << ""FE_UNDERFLOW "";
	}
	else
		cout << ""None"";

	cout << endl;
}

void print_current_rounding_direction()
{
	cout << ""Current rounding method: "";
	switch (fegetround()) {
		case FE_TONEAREST:
			cout << ""FE_TONEAREST"";
			break;
		case FE_DOWNWARD:
			cout << ""FE_DOWNWARD"";
			break;
		case FE_UPWARD:
			cout << ""FE_UPWARD"";
			break;
		case FE_TOWARDZERO:
			cout << ""FE_TOWARDZERO"";
			break;
		default:
			cout << ""unknown"";
	};
	cout << endl;
}

void print_environment()
{
	print_exceptions();
	print_current_rounding_direction();
}

int main(void)
{
	cout << ""Initial environment "" << endl;
	print_environment();
	fenv_t envp;

	/* Save current environment */
	fegetenv(&envp);
	feraiseexcept(FE_INVALID|FE_DIVBYZERO);
	fesetround(FE_DOWNWARD);
	cout << ""After changing environment "" << endl;
	print_environment();

	/* Restores previous environment */
	fesetenv(&envp);
	cout << ""Restoring initial environment "" << endl;
	print_environment();
	return 0;
}",int fesetenv( fenv_t* envp );,envp: Pointer to an object of type fenv_t that stores the status of the floating point environment.,"Initial environment
Raised exceptions: None
Current rounding method: FE_TONEAREST
After changing environment
Raised exceptions: FE_DIVBYZERO FE_INVALID
Current rounding method: FE_DOWNWARD
Restoring initial environment
Raised exceptions: None
Current rounding method: FE_TONEAREST",Cfenv
fesetround(),The fesetround() function in C++ attempts to set the specified floating point rounding direction which is expected to be one of the floating point rounding macros.,"#include <iostream>
#include <cmath>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_current_rounding_direction()
{
	cout << ""Current rounding method: "";
	switch (fegetround()) {
		case FE_TONEAREST:
			cout << ""FE_TONEAREST"";
			break;
		case FE_DOWNWARD:
			cout << ""FE_DOWNWARD"";
			break;
		case FE_UPWARD:
			cout << ""FE_UPWARD"";
			break;
		case FE_TOWARDZERO:
			cout << ""FE_TOWARDZERO"";
			break;
		default:
			cout << ""unknown"";
	};
	cout << endl;
}

int main()
{
	print_current_rounding_direction();
	cout << ""6.2 -> "" << rint(6.2) << endl;
	cout << ""18.7 -> "" << rint(18.7) << endl;

	fesetround(FE_UPWARD);
	print_current_rounding_direction();
	cout << ""6.2 -> "" << rint(6.2) << endl;
	cout << ""19.7 -> "" << rint(19.7) << endl;
	
	fesetround(FE_DOWNWARD);
	print_current_rounding_direction();
	cout << ""6.2 -> "" << rint(6.2) << endl;
	cout << ""19.7 -> "" << rint(19.7) << endl;
	
	return 0;
}",int fesetround( int round );,"round: Rounding direction which is one of floating point rounding macros. The possible values for round are FE_TONEAREST, FE_DOWNWARD, FE_UPWARD, FE_TOWARDZERO.","Current rounding method: FE_TONEAREST
6.2 -> 6
18.7 -> 19
Current rounding method: FE_UPWARD
6.2 -> 7
19.7 -> 20
Current rounding method: FE_DOWNWARD
6.2 -> 6
19.7 -> 19",Cfenv
fegetenv(),The fegetenv() function in C++ attempts to store the status of the floating point environment in an object of type fenv_t.,"#include <iostream>
#include <cmath>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_exceptions()
{
	cout << ""Raised exceptions: "";
	if(fetestexcept(FE_ALL_EXCEPT))
	{
		if(fetestexcept(FE_DIVBYZERO))
			cout << ""FE_DIVBYZERO "";
		if(fetestexcept(FE_INEXACT))
			cout << ""FE_INEXACT "";
		if(fetestexcept(FE_INVALID))
			cout << ""FE_INVALID "";
		if(fetestexcept(FE_OVERFLOW))
			cout << ""FE_OVERFLOW "";
		if(fetestexcept(FE_UNDERFLOW))
			cout << ""FE_UNDERFLOW "";
	}
	else
		cout << ""None"";

	cout << endl;
}

void print_current_rounding_direction()
{
	cout << ""Current rounding method: "";
	switch (fegetround()) {
		case FE_TONEAREST:
			cout << ""FE_TONEAREST"";
			break;
		case FE_DOWNWARD:
			cout << ""FE_DOWNWARD"";
			break;
		case FE_UPWARD:
			cout << ""FE_UPWARD"";
			break;
		case FE_TOWARDZERO:
			cout << ""FE_TOWARDZERO"";
			break;
		default:
			cout << ""unknown"";
	};
	cout << endl;
}

void print_environment()
{
	print_exceptions();
	print_current_rounding_direction();
}

int main(void)
{
	cout << ""Initial environment "" << endl;
	print_environment();
	fenv_t envp;

	/* Save current environment */
	fegetenv(&envp);
	feraiseexcept(FE_INVALID|FE_DIVBYZERO);
	fesetround(FE_DOWNWARD);
	cout << ""After changing environment "" << endl;
	print_environment();

	/* Restores previous environment */
	fesetenv(&envp);
	cout << ""Restoring initial environment "" << endl;
	print_environment();
	
	return 0;
}",int fegetenv( fenv_t* envp );,envp: Pointer to an object of type fenv_t that stores the status of the floating point environment.,"Initial environment
Raised exceptions: None
Current rounding method: FE_TONEAREST
After changing environment
Raised exceptions: FE_DIVBYZERO FE_INVALID
Current rounding method: FE_DOWNWARD
Restoring initial environment
Raised exceptions: None
Current rounding method: FE_TONEAREST",Cfenv
fegetround(),The fegetround() function in C++ is used to obtain the value of the floating point rounding macro that corresponds to the current rounding direction.,"#include <iostream>
#include <cmath>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_current_rounding_direction()
{
	cout << ""Current rounding method: "";
	switch (fegetround()) {
		case FE_TONEAREST:
			cout << ""FE_TONEAREST"";
			break;
		case FE_DOWNWARD:
			cout << ""FE_DOWNWARD"";
			break;
		case FE_UPWARD:
			cout << ""FE_UPWARD"";
			break;
		case FE_TOWARDZERO:
			cout << ""FE_TOWARDZERO"";
			break;
		default:
			cout << ""unknown"";
	};
	cout << endl;
}

int main(void)
{
	print_current_rounding_direction();
	cout << ""6.2 -> "" << rint(6.2) << endl;
	cout << ""18.7 -> "" << rint(18.7) << endl;

	fesetround(FE_UPWARD);
	print_current_rounding_direction();
	cout << ""6.2 -> "" << rint(6.2) << endl;
	cout << ""19.7 -> "" << rint(19.7) << endl;
	
	fesetround(FE_DOWNWARD);
	print_current_rounding_direction();
	cout << ""6.2 -> "" << rint(6.2) << endl;
	cout << ""19.7 -> "" << rint(19.7) << endl;

	return 0;
}",int fegetround();,None,"Current rounding method: FE_TONEAREST
6.2 -> 6
18.7 -> 19
Current rounding method: FE_UPWARD
6.2 -> 7
19.7 -> 20
Current rounding method: FE_DOWNWARD
6.2 -> 6
19.7 -> 19",Cfenv
fesetexceptflag(),The fesetexceptflag() function in C++ sets specified floating point exception flags from a pointer object into the floating point environment.,"#include <iostream>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_exceptions()
{
	cout << ""Raised exceptions: "";
	if(fetestexcept(FE_ALL_EXCEPT))
	{
		if(fetestexcept(FE_DIVBYZERO))
			cout << ""FE_DIVBYZERO "";
		if(fetestexcept(FE_INEXACT))
			cout << ""FE_INEXACT "";
		if(fetestexcept(FE_INVALID))
			cout << ""FE_INVALID "";
		if(fetestexcept(FE_OVERFLOW))
			cout << ""FE_OVERFLOW "";
		if(fetestexcept(FE_UNDERFLOW))
			cout << ""FE_UNDERFLOW "";
	}
	else
		cout << ""None"";

	cout << endl;
}

int main()
{
	fexcept_t excepts;
	feraiseexcept(FE_DIVBYZERO);
	
	/* save current state*/
	fegetexceptflag(&excepts,FE_ALL_EXCEPT);
	print_exceptions();
	feraiseexcept(FE_INVALID|FE_OVERFLOW);
	print_exceptions();
	
	/* restoring previous exceptions */
	fesetexceptflag(&excepts,FE_ALL_EXCEPT);
	print_exceptions();
	
	return 0;
}","int fesetexceptflag( const fexcept_t* flagp, int excepts );","flagp: A pointer to an fexcept_t object where the flags will be read from.
excepts: Bitmask listing of exception flags to set.Bitmask accepted macros


Macro
Type
Description




FE_DIVBYZERO
Pole error
Division by zero


FE_INEXACT
Inexact
Not exact results such as (1.0/3.0)


FE_INVALID
Domain error
At least one arguments used is a value for which the function is not defined


FE_OVERFLOW
Overflow range error
Result is too large in magnitude to be represented by the return type


FE_UNDERFLOW
Underflow range error
Result is too small in magnitude to be represented by the return type


FE_ALL_EXCEPT
All exceptions
All exceptions supported by the implementation","Raised exceptions: FE_DIVBYZERO
Raised exceptions: FE_DIVBYZERO FE_INVALID FE_OVERFLOW
Raised exceptions: FE_DIVBYZERO",Cfenv
fegetexceptflag(),"The fegetexceptflag() function in C++ gets floating point exception flags specified the argument excepts, and stores it in the point specified by flagp.","#include <iostream>
#include <cfenv>
#pragma STDC FENV_ACCESS ON
using namespace std;

void print_exceptions()
{
	cout << ""Raised exceptions: "";
	if(fetestexcept(FE_ALL_EXCEPT))
	{
		if(fetestexcept(FE_DIVBYZERO))
			cout << ""FE_DIVBYZERO "";
		if(fetestexcept(FE_INEXACT))
			cout << ""FE_INEXACT "";
		if(fetestexcept(FE_INVALID))
			cout << ""FE_INVALID "";
		if(fetestexcept(FE_OVERFLOW))
			cout << ""FE_OVERFLOW "";
		if(fetestexcept(FE_UNDERFLOW))
			cout << ""FE_UNDERFLOW "";
	}
	else
		cout << ""None"";

	cout << endl;
}
int main()
{
	fexcept_t excepts;
	feraiseexcept(FE_DIVBYZERO);
	
	/* save current state*/
	fegetexceptflag(&excepts,FE_ALL_EXCEPT);
	print_exceptions();
	feraiseexcept(FE_INVALID|FE_OVERFLOW);
	print_exceptions();
	
	/* restoring previous exceptions */
	fesetexceptflag(&excepts,FE_ALL_EXCEPT);
	print_exceptions();
	
	return 0;
}","int fegetexceptflag(fexcept_t* flagp, int excepts);","flagp: A pointer to an fexcept_t object where the flags will be stored.
excepts: Bitmask listing of exception flags to get.Bitmask accepted macros


Macro
Type
Description




FE_DIVBYZERO
Pole error
Division by zero


FE_INEXACT
Inexact
Not exact results such as (1.0/3.0)


FE_INVALID
Domain error
At least one arguments used is a value for which the function is not defined


FE_OVERFLOW
Overflow range error
Result is too large in magnitude to be represented by the return type


FE_UNDERFLOW
Underflow range error
Result is too small in magnitude to be represented by the return type


FE_ALL_EXCEPT
All exceptions
All exceptions supported by the implementation","Raised exceptions: FE_DIVBYZERO
Raised exceptions: FE_DIVBYZERO FE_INVALID FE_OVERFLOW
Raised exceptions: FE_DIVBYZERO",Cfenv
feraiseexcept(),The feraiseexcept() function in C++ attempts to raise all the floating point exceptions specified by the argument.,"#include <iostream>
#include <fenv.h>
#pragma STDC FENV_ACCESS ON
using namespace std;

int main()
{
	int retVal;
	feclearexcept(FE_ALL_EXCEPT);

	retVal = feraiseexcept(FE_OVERFLOW | FE_INVALID);
	if (retVal == 0)
		cout << ""Successfully raised FE_OVERFLOW and FE_INVALID"" << endl;
	else
		cout << ""Raising FE_OVERFLOW and FE_INVALID failed"" << endl;

	return 0;
}",int feraiseexcept(int excepts);,"excepts: Bitmask listing of exception flags to raise.Bitmask accepted macros


Macro
Type
Description




FE_DIVBYZERO
Pole error
Division by zero


FE_INEXACT
Inexact
Not exact results such as (1.0/3.0)


FE_INVALID
Domain error
At least one arguments used is a value for which the function is not defined


FE_OVERFLOW
Overflow range error
Result is too large in magnitude to be represented by the return type


FE_UNDERFLOW
Underflow range error
Result is too small in magnitude to be represented by the return type


FE_ALL_EXCEPT
All exceptions
All exceptions supported by the implementation",Successfully raised FE_OVERFLOW and FE_INVALID,Cfenv
feclearexcept(),The feclearexcept() function in C++ attempts to clear the floating point exception flags specified by the argument excepts.,"#include <iostream>
#include <cfenv>
#include <cmath>
#pragma STDC FENV_ACCESS ON
using namespace std;

int main()
{
	// clears all exceptions
	feclearexcept(FE_ALL_EXCEPT);
	cout << ""1/0 = "" << 1.0/0.0 << endl;
	
	// tests if above statement raised the FE_DIVBYZERO exception
	if(fetestexcept(FE_DIVBYZERO))
	{
		cout << ""FE_DIVBYZERO is set"" << endl;
	}
	else
	{
		cout << ""FE_DIVBYZERO is not set"" << endl;
	}

	feclearexcept(FE_ALL_EXCEPT);
	cout << ""sqrt(-1) = "" << sqrt(-1) << endl;

	if(fetestexcept(FE_INVALID))
	{
		cout << ""FE_INVALID is set"" << endl;
	}
	else
	{
		cout << ""FE_INVALID is not set"" << endl;
	}
}",int feclearexcept(int excepts);,"excepts: Bitmask listing of exception flags to clearBitmask accepted macros


Macro
Type
Description




FE_DIVBYZERO
Pole error
Division by zero


FE_INEXACT
Inexact
Not exact results such as (1.0/3.0)


FE_INVALID
Domain error
At least one arguments used is a value for which the function is not defined


FE_OVERFLOW
Overflow range error
Result is too large in magnitude to be represented by the return type


FE_UNDERFLOW
Underflow range error
Result is too small in magnitude to be represented by the return type


FE_ALL_EXCEPT
All exceptions
All exceptions supported by the implementation","1/0 = inf
FE_DIVBYZERO is set
sqrt(-1) = -nan
FE_INVALID is set",Cfenv
strftime(),The strftime() function in C++ converts the given date and time from a given calendar time time to a null-terminated multibyte character string according to a format string.,"#include <ctime>
#include <iostream>
using namespace std;

int main()
{
	time_t curr_time;
	tm * curr_tm;
	char date_string[100];
	char time_string[100];
	
	time(&curr_time);
	curr_tm = localtime(&curr_time);
	
	strftime(date_string, 50, ""Today is %B %d, %Y"", curr_tm);
	strftime(time_string, 50, ""Current time is %T"", curr_tm);
	
	cout << date_string << endl;
	cout << time_string << endl;
	
	return 0;
}","size_t strftime( char* str, size_t count, const char* format, const tm* time );","str: Pointer to the first element of the character array to store the result.
count: Maximum number of bytes to write.
format: Pointer to a null-terminated multibyte character string specifying the format of conversion. The format string consists of conversion specifier (beginning with % and optionally followed by E or O) and other ordinary characters.
		The ordinary characters including the terminating null character are copied as it is to the output string.
		
strftime() format specifiers


Conversion Specifier
Description
Used Fields




%
Writes the character %


n
Writes newline character


t
Writes horizontal tab character


Year


Y
Writes 4 digits of year, e.g. 2011
tm_year


EY
Writes 4 digits of year in locale's alternative representation
tm_year


y
Writes last 2 digits of year, range [00, 99]
tm_year


Oy
Writes the last 2 digits of year in locale's alternative representation
tm_year


Ey
Writes year as offset from locale's alternative calendar period %EC (locale-dependent)
tm_year


C
Writes first 2 digits of year, range [00,99]
tm_year


EC
Writes name of the base year (period) in the locale's alternative representation,
tm_year


G
Writes ISO 8601 week-based year, i.e. the year that contains the specified week.
tm_year, tm_wday, tm_yday


g
Writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]).
tm_year, tm_wday, tm_yday


Month


b
Writes abbreviated month name, e.g. Jan
tm_mon


h
Same as b
tm_mon


B
Writes full month name, e.g. January
tm_mon


m
Writes month as a decimal number, range [01,12]
tm_mon


Om
Writes month using the locale's alternative numeric system
tm_mon


Week


U
Writes week of the year as a decimal number from 00 to 53 (Sunday is the first day of the week)
tm_year, tm_wday, tm_yday


OU
Writes week of the year as by %U using the alternative numeric system
tm_year, tm_wday, tm_yday


W
Writes week of the year as a decimal number from 00 to 53 (Monday is the first day of the week)
tm_year, tm_wday, tm_yday


OW
Writes week of the year as by %W using the alternative numeric system
tm_year, tm_wday, tm_yday


V
Writes ISO 8601 week of the year (range [01,53]).
tm_year, tm_wday, tm_yday


OV
Writes week of the year, as by %V, using the alternative numeric system
tm_year, tm_wday, tm_yday


Day of the year/month


j
Writes day of the year as a decimal number, range [001,366]
tm_yday


d
Writes day of the month as a decimal number, range[01,31]
tm_mday


Od
Writes day of the month, as by %d, using the alternative numeric system
tm_mday


e
Writes day of the month as a decimal number, range[1,31]
tm_mday


Oe
Writes day of the month, as by %e, using the alternative numeric system
tm_mday


Day of the week


a
Writes abbreviated weekday name, e.g. Fri (locale dependent)
tm_wday


A
Writes full weekday name, e.g. Friday (locale dependent)
tm_wday


w
Writes weekday as a decimal number, range [0-6] (Sunday is 0)
tm_wday


Ow
Writes weekday as by %w, using the alternative numeric system
tm_wday


u
Writes weekday as a decimal number, where Monday is 1 (ISO 8601 format), range [1-7]
tm_wday


Ou
Writes weekday as by %u, using the alternative numeric system
tm_wday


Hour, minute, second


H
Writes hour as a decimal number, range [00,23]
tm_hour


OH
Writes hour as by %H, using the alternative numeric system
tm_hour


I
Writes hour as a decimal number, range[01,12]
tm_hour


OI
Writes hour as by %I, using the alternative numeric system
tm_hour


M
Writes minute as a decimal number, range [00,59]
tm_min


OM
Writes minute as by %M, using the alternative numeric system
tm_min


S
Writes second as a decimal number, range [00,60]
tm_sec


OS
Writes second as by %S, using the alternative numeric system
tm_sec


Other


c
Writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)
all


Ec
Writes locale's alternative date and time string
all


x
Writes localized date representation (locale dependent)
all


Ex
Writes locale's alternative date representation
all


X
Writes localized time representation (locale dependent)
all


EX
Writes locale's alternative time representation
all


D
Equivalent to ""%m/%d/%y""
tm_mon, tm_mday, tm_year


F
Equivalent to ""%Y-%m-%d""
tm_mon, tm_mday, tm_year


r
Writes localized 12-hour clock time
tm_hour, tm_min, tm_sec


R
Equivalent to ""%H:%M""
tm_hour, tm_min


T
Equivalent to ""%H:%M:%S
tm_hour, tm_min, tm_sec


P
Writes localized a.m. or p.m. (locale dependent)
tm_hour


z
writes offset from UTC in the ISO 8601 format (e.g. -0545), or no characters if the time zone information is not available
tm_isdst


Z
Writes time zone name or abbreviation, or nothing if the time zone information is not available (locale dependent)
tm_isdst




time: The date and time information to convert.","Today is April 21, 2017
Current time is 11:20:42",Ctime
mktime(),The mktime() function in C++ converts the local calendar time to the time since epoch and returns the value as an object of type time_t.,"#include <iostream>
#include <ctime>
using namespace std;

int main ()
{
	time_t tim;
	tm *ptr;

	int y = 2017, m = 4, d = 20;
	char weekday[7][20] = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
	
	time(&tim);
	ptr = localtime(&tim);

	// tm_year is time since 1900
	ptr->tm_year = y - 1900;
	ptr->tm_mon = m - 1;
	ptr->tm_mday = d;
	
	mktime (ptr);
	cout << ""April 20, 2017 was "" << weekday[ptr->tm_wday];
	
	return 0;
}",time_t mktime(tm* time);,time: A pointer to a tm object that represents the local calendar time to convert.,"April 4, 2017 was a Thursday",Ctime
localtime(),The localtime() function in C++ converts the given time since epoch to calendar time which is expressed as local time.,"#include <iostream>
#include <ctime>
using namespace std;

int main()
{
	time_t curr_time;
	curr_time = time(NULL);

	tm *tm_local = localtime(&curr_time);
	cout << ""Current local time : "" << tm_local->tm_hour << "":"" << tm_local->tm_min << "":"" << tm_local->tm_sec;
	return 0;
}",tm* localtime(const time_t* time_pretr);,time_ptr: pointer to a time_t object to be converted.,Current local time : 19:20:14,Ctime
gmtime(),The gmtime() function in C++ converts the given time since epoch to calendar time which is expressed as UTC time rather than local time.,"#include <iostream>
#include <ctime>
using namespace std;

int main()
{
	time_t curr_time;
	curr_time = time(NULL);

	tm *tm_gmt = gmtime(&curr_time);
	cout << ""Current time : "" << tm_gmt->tm_hour << "":"" << tm_gmt->tm_min << "":"" << tm_gmt->tm_sec << "" GMT"";
	return 0;
}",tm* gmtime(const time_t* time_ptr);,time_ptr: pointer to a time_t object to be converted.,Current time : 13:26:28 GMT,Ctime
ctime(),The ctime() function in C++ converts the given time since epoch to a calendar local time and then to a character representation.,"#include <iostream>
#include <ctime>
using namespace std;

int main()
{
	time_t curr_time;
	curr_time = time(NULL);

	char *tm = ctime(&curr_time);
	cout << ""Today is : "" << tm;
	
	return 0;
}",char* ctime(const time_t* time_ptr);,time_ptr: pointer to a time_t object to be converted.,Today is : Fri Mar 24 18:48:04 2017,Ctime
asctime(),The asctime() function in C++ converts the given calendar time of structure tm to a character representation.,"#include <iostream>
#include <ctime>
using namespace std;

int main()
{
	time_t curr_time;

	time(&curr_time);
	cout << ""Current date and time: "" << asctime(localtime(&curr_time));

	return 0;
}",char* asctime(const struct tm * time_ptr);,time_ptr: pointer to a tm object to be converted.,Current date and time: Tue Mar 21 13:52:57 2017,Ctime
time(),The time() function in C++ returns the current calendar time as an object of type time_t.,"#include <ctime>
#include <iostream>
using namespace std;

int main()
{
	time_t current_time;

	current_time = time(NULL);
	cout << current_time << "" seconds has passed since 00:00:00 GMT, Jan 1, 1970"";

	return 0;
}",time_t time(time_t* arg);,arg: pointer to a time_t object which (if not null) stores the time.,"1489924627 seconds has passed since 00:00:00 GMT, Jan 1, 1970",Ctime
difftime(),The difftime() function in C++ computes the difference between two times in seconds.,"#include <iostream>
#include <ctime>

using namespace std;

int main()
{
	time_t start, finish;
	long product;

	time(&start);
	for(int i=0; i<10000; i++)
	{
		for(int j=0; j<100000; j++)
		{
			product = i*j;
		}
	}
	time(&finish);
	cout << ""Time required = "" << difftime(finish, start) << "" seconds"";
	return 0;
}","double difftime(time_t end,time_t begin);","end: Represent the end time.
begin: Represent the beginning time.",Time required = 3 seconds,Ctime
clock(),The clock() function in C++ returns the approximate processor time that is consumed by the program.,"#include <iostream>
#include <ctime>
#include <cmath>
using namespace std;

int main ()
{
	float x,y;
	clock_t time_req;

	// Using pow function
	time_req = clock();
	for(int i=0; i<100000; i++)
	{
		y = log(pow(i,5));
	}
	time_req = clock() - time_req;
	cout << ""Using pow function, it took "" << (float)time_req/CLOCKS_PER_SEC << "" seconds"" << endl;
	
	// Without pow function
	time_req = clock();
	for(int i=0; i<100000; i++)
	{
		y = log(i*i*i*i*i);
	}
	time_req = clock()- time_req;
	cout << ""Without using pow function, it took "" << (float)time_req/CLOCKS_PER_SEC << "" seconds"" << endl;

	return 0;
}",clock_t clock();,None,"Using pow function, it took 0.014743 seconds

Without using pow function, it took 0.001357 seconds",Ctime
